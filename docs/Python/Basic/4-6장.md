- 4. Choose with if.
   - Comment with #
   - Continue Lines with \
   - Compare with if, elif, and else
   - What Is True?
   - Do Multiple Comparisons with in
   - New: I Am the Walrus
   - Coming Up
   - Things to Do
- 5. Text Strings.
   - Create with Quotes
   - Create with str()
   - Escape with \
   - Combine by Using +
   - Duplicate with *
   - Get a Character with []
   - Get a Substring with a Slice
   - Get Length with len()
   - Split with split()
   - Combine by Using join()
   - Substitute by Using replace()
   - Strip with strip()
   - Search and Select
   - Case
   - Alignment
   - Formatting
      - Old style: %
      - New style: {} and format()
      - Newest Style: f-strings
   - More String Things
   - Coming Up
   - Things to Do
- 6. Loop with while and for.
   - Repeat with while
      - Cancel with break
      - Skip Ahead with continue
      - Check break Use with else
   - Iterate with for and in
      - Cancel with break
      - Skip with continue
      - Check break Use with else
      - Generate Number Sequences with range()
   - Other Iterators
   - Coming Up
   - Things to Do




**CHAPTER 4**

**Choose with if**

```
If you can keep your head when all about you
Are losing theirs and blaming it on you, ...
—Rudyard Kipling, If—
```
In the previous chapters, you’ve seen many examples of data but haven’t done much

with them. Most of the code examples used the interactive interpreter and were short.

In this chapter, you learn how to structure Python code, not just data.

Many computer languages use characters such as curly braces ({ and }) or keywords

such as begin and end to mark off sections of code. In those languages, it’s good prac‐

tice to use consistent indentation to make your program more readable for yourself

and others. There are even tools to make your code line up nicely.

When he was designing the language that became Python, Guido van Rossum deci‐

ded that the indentation itself was enough to define a program’s structure, and avoi‐

ded typing all those parentheses and curly braces. Python is unusual in this use of

white space to define program structure. It’s one of the first aspects that newcomers

notice, and it can seem odd to those who have experience with other languages. It

turns out that after writing Python for a little while, it feels natural, and you stop

noticing it. You even get used to doing more while typing less.

Our initial code examples have been one-liners. Let’s first see how to make comments

and multiple-line commands.

### Comment with #

A comment is a piece of text in your program that is ignored by the Python inter‐

preter. You might use comments to clarify nearby Python code, make notes to your‐

self to fix something someday, or for whatever purpose you like. You mark a

```
Choose with if | 53
```

```
1 Like that eight-legged green thing that’s right behind you!
2 Please don’t call it. It might come back.
```
comment by using the # character; everything from that point on to the end of the

current line is part of the comment. You’ll usually see a comment on a line by itself, as

shown here:

```
>>> # 60 sec/min * 60 min/hr * 24 hr/day
>>> seconds_per_day = 86400
```
Or, on the same line as the code it’s commenting:

```
>>> seconds_per_day = 86400 # 60 sec/min * 60 min/hr * 24 hr/day
```
The # character has many names: hash, sharp, pound, or the sinister-sounding octo‐

thorpe.^1 Whatever you call it,^2 its effect lasts only to the end of the line on which it

appears.

Python does not have a multiline comment. You need to explicitly begin each com‐

ment line or section with a #:

```
>>> # I can say anything here, even if Python doesn't like it,
... # because I'm protected by the awesome
... # octothorpe.
```
```
>>>
```
However, if it’s in a text string, the mighty octothorpe reverts back to its role as a plain

old # character:

```
>>> print ("No comment: quotes make the # harmless.")
No comment: quotes make the # harmless.
```
### Continue Lines with \

Programs are more readable when lines are reasonably short. The recommended (not

required) maximum line length is 80 characters. If you can’t say everything you want

to say in that length, you can use the continuation character: \ (backslash). Just put \

at the end of a line, and Python will suddenly act as though you’re still on the same

line.

For example, if I wanted to add the first five digits, I could do it a line at a time:

```
>>> sum = 0
>>> sum += 1
>>> sum += 2
>>> sum += 3
>>> sum += 4
>>> sum
10
```
```
54
```
**54 | Chapter 4: Choose with if**


Or, I could do it in one step, using the continuation character:

```
>>> sum = 1 + \
... 2 + \
... 3 + \
... 4
>>> sum
10
```
If we skipped the backslash in the middle of an expression, we’d get an exception:

```
>>> sum = 1 +
File "<stdin>", line 1
sum = 1 +
^
SyntaxError: invalid syntax
```
Here’s a little trick—if you’re in the middle of paired parentheses (or square or curly

brackets), Python doesn’t squawk about line endings:

```
>>> sum = (
... 1 +
... 2 +
... 3 +
... 4)
>>>
>>> sum
10
```
You’ll also see in Chapter 5 that paired triple quotes let you make multiline strings.

### Compare with if, elif, and else

Now, we finally take our first step into the code structures that weave data into pro‐

grams. Our first example is this tiny Python program that checks the value of the

boolean variable disaster and prints an appropriate comment:

```
>>> disaster = True
>>> if disaster:
... print ("Woe!")
... else :
... print ("Whee!")
...
Woe!
>>>
```
The if and else lines are Python statements that check whether a condition (here,

the value of disaster) is a boolean True value, or can be evaluated as True. Remem‐

ber, print() is Python’s built-in function to print things, normally to your screen.

```
Compare with if, elif, and else | 55
```

```
If you’ve programmed in other languages, note that you don’t need
parentheses for the if test. For example, don’t say something such
as if (disaster == True) (the equality operator == is described
in a few paragraphs). You do need the colon (:) at the end. If, like
me, you forget to type the colon at times, Python will display an
error message.
```
Each print() line is indented under its test. I used four spaces to indent each subsec‐

tion. Although you can use any indentation you like, Python expects you to be consis‐

tent with code within a section—the lines need to be indented the same amount, lined

up on the left. The recommended style, called PEP-8, is to use four spaces. Don’t use

tabs, or mix tabs and spaces; it messes up the indent count.

We did a number of things here, which I explain more fully as the chapter progresses:

- Assigned the boolean value True to the variable named disaster
- Performed a conditional comparison by using if and else, executing different
    code depending on the value of disaster
- Called the print() function to print some text

You can have tests within tests, as many levels deep as needed:

```
>>> furry = True
>>> large = True
>>> if furry:
... if large:
... print ("It's a yeti.")
... else :
... print ("It's a cat!")
... else :
... if large:
... print ("It's a whale!")
... else :
... print ("It's a human. Or a hairless cat.")
...
It's a yeti.
```
In Python, indentation determines how the if and else sections are paired. Our first

test was to check furry. Because furry is True, Python goes to the indented if large

test. Because we had set large to True, if large is evaluated as True, and the

following else line is ignored. This makes Python run the line indented under if

large: and print It's a yeti.

If there are more than two possibilities to test, use if for the first, elif (meaning else

if) for the middle ones, and else for the last:

**56 | Chapter 4: Choose with if**


```
>>> color = "mauve"
>>> if color == "red":
... print ("It's a tomato")
... elif color == "green":
... print ("It's a green pepper")
... elif color == "bee purple":
... print ("I don't know what it is, but only bees can see it")
... else :
... print ("I've never heard of the color", color)
...
I've never heard of the color mauve
```
In the preceding example, we tested for equality by using the == operator. Here are

Python’s comparison operators:

```
equality ==
inequality !=
less than <
less than or equal <=
greater than >
greater than or equal >=
```
These return the boolean values True or False. Let’s see how these all work, but first,

assign a value to x:

```
>>> x = 7
```
Now, let’s try some tests:

```
>>> x == 5
False
>>> x == 7
True
>>> 5 < x
True
>>> x < 10
True
```
Note that two equals signs (==) are used to test equality; remember, a single equals

sign (=) is what you use to assign a value to a variable.

If you need to make multiple comparisons at the same time, you use the logical (or

boolean) operators and, or, and not to determine the final boolean result.

Logical operators have lower precedence than the chunks of code that they’re compar‐

ing. This means that the chunks are calculated first, and then compared. In this

example, because we set x to 7 , 5 < x is calculated to be True and x < 10 is also True,

so we finally end up with True and True:

```
Compare with if, elif, and else | 57
```

```
>>> 5 < x and x < 10
True
```
As “Precedence” on page 43 points out, the easiest way to avoid confusion about

precedence is to add parentheses:

```
>>> (5 < x) and (x < 10)
True
```
Here are some other tests:

```
>>> 5 < x or x < 10
True
>>> 5 < x and x > 10
False
>>> 5 < x and not x > 10
True
```
If you’re and-ing multiple comparisons with one variable, Python lets you do this:

```
>>> 5 < x < 10
True
```
It’s the same as 5 < x and x < 10. You can also write longer comparisons:

```
>>> 5 < x < 10 < 999
True
```
### What Is True?

What if the element we’re checking isn’t a boolean? What does Python consider True

and False?

A false value doesn’t necessarily need to explicitly be a boolean False. For example,

these are all considered False:

```
boolean False
null None
zero integer 0
zero float 0.0
empty string ''
empty list []
empty tuple ()
empty dict {}
empty set set()
```
Anything else is considered True. Python programs use these definitions of “truthi‐

ness” and “falsiness” to check for empty data structures as well as False conditions:

**58 | Chapter 4: Choose with if**


```
>>> some_list = []
>>> if some_list:
... print ("There's something in here")
... else :
... print ("Hey, it's empty!")
```
```
Hey, it's empty!
```
If what you’re testing is an expression rather than a simple variable, Python evaluates

the expression and returns a boolean result. So, if you type:

```
if color == "red":
```
Python evaluates color == "red". In our earlier example, we assigned the string

"mauve" to color, so color == "red" is False, and Python moves on to the next test:

```
elif color == "green":
```
### Do Multiple Comparisons with in

Suppose that you have a letter and want to know whether it’s a vowel. One way would

be to write a long if statement:

```
>>> letter = 'o'
>>> if letter == 'a' or letter == 'e' or letter == 'i' \
... or letter == 'o' or letter == 'u':
... print (letter, 'is a vowel')
... else :
... print (letter, 'is not a vowel')
...
o is a vowel
>>>
```
Whenever you need to make a lot of comparisons like that, separated by or, use

Python’s membership operator in, instead. Here’s how to check vowel-ness more

Pythonically, using in with a string made of vowel characters:

```
>>> vowels = 'aeiou'
>>> letter = 'o'
>>> letter in vowels
True
>>> if letter in vowels:
... print (letter, 'is a vowel')
...
o is a vowel
```
Here’s a preview of how to use in with some data types that you’ll read about in detail

in the next few chapters:

```
>>> letter = 'o'
>>> vowel_set = {'a', 'e', 'i', 'o', 'u'}
>>> letter in vowel_set
```
```
Do Multiple Comparisons with in | 59
```

```
True
>>> vowel_list = ['a', 'e', 'i', 'o', 'u']
>>> letter in vowel_list
True
>>> vowel_tuple = ('a', 'e', 'i', 'o', 'u')
>>> letter in vowel_tuple
True
>>> vowel_dict = {'a': 'apple', 'e': 'elephant',
... 'i': 'impala', 'o': 'ocelot', 'u': 'unicorn'}
>>> letter in vowel_dict
True
>>> vowel_string = "aeiou"
>>> letter in vowel_string
True
```
For the dictionary, in looks at the keys (the lefthand side of the :) instead of their

values.

### New: I Am the Walrus

Arriving in Python 3.8 is the walrus operator, which looks like this:

```
name := expression
```
See the walrus? (Like a smiley, but tuskier.)

Normally, an assignment and test take two steps:

```
>>> tweet_limit = 280
>>> tweet_string = "Blah" * 50
>>> diff = tweet_limit - len(tweet_string)
>>> if diff >= 0:
... print ("A fitting tweet")
... else :
... print ("Went over by", abs(diff))
...
A fitting tweet
```
With our new tusk power (aka assignment expressions) we can combine these into

one step:

```
>>> tweet_limit = 280
>>> tweet_string = "Blah" * 50
>>> if diff := tweet_limit - len(tweet_string) >= 0:
... print ("A fitting tweet")
... else :
... print ("Went over by", abs(diff))
...
A fitting tweet
```
The walrus also gets on swimmingly with for and while, which we look at in

Chapter 6.

**60 | Chapter 4: Choose with if**


### Coming Up

Play with strings, and meet interesting characters.

### Things to Do

4.1 Choose a number between 1 and 10 and assign it to the variable secret. Then,

select another number between 1 and 10 and assign it to the variable guess. Next,

write the conditional tests (if, else, and elif) to print the string 'too low' if guess

is less than secret, 'too high' if greater than secret, and 'just right' if equal to

secret.

4.2 Assign True or False to the variables small and green. Write some if/else state‐

ments to print which of these matches those choices: cherry, pea, watermelon,

pumpkin.

```
Coming Up | 61
```


**CHAPTER 5**

**Text Strings**

```
I always liked strange characters.
—Tim Burton
```
Computer books often give the impression that programming is all about math.

Actually, most programmers work with strings of text more often than numbers. Log‐

ical (and creative!) thinking is often more important than math skills.

Strings are our first example of a Python sequence. In this case, they’re a sequence of

characters. But what’s a character? It’s the smallest unit in a writing system, and

includes letters, digits, symbols, punctuation, and even white space or directives like

linefeeds. A character is defined by its meaning (how it’s used), not how it looks. It

can have more than one visual representation (in different fonts), and more than one

character can have the same appearance (such as the visual H, which means the H

sound in the Latin alphabet but the Latin N sound in Cyrillic).

This chapter concentrates on how to make and format simple text strings, using

ASCII (basic character set) examples. Two important text topics are deferred to

Chapter 12: Unicode characters (like the H and N issue I just mentioned) and regular

expressions (pattern matching).

Unlike other languages, strings in Python are immutable. You can’t change a string in

place, but you can copy parts of strings to another string to get the same effect. We

look at how to do this shortly.

##### 63


### Create with Quotes

You make a Python string by enclosing characters in matching single or double

quotes:

```
>>> 'Snap'
'Snap'
>>> "Crackle"
'Crackle'
```
The interactive interpreter echoes strings with a single quote, but all are treated

exactly the same by Python.

```
Python has a few special types of strings, indicated by a letter
before the first quote. f or F starts an f string, used for formatting,
and described near the end of this chapter. r or R starts a raw string,
used to prevent escape sequences in the string (see “Escape with \”
on page 66 and Chapter 12 for its use in string pattern matching).
Then, there’s the combination fr (or FR, Fr, or fR) that starts a raw
f-string. A u starts a Unicode string, which is the same as a plain
string. And a b starts a value of type bytes (Chapter 12). Unless I
mention one of these special types, I’m always talking about plain
old Python Unicode text strings.
```
Why have two kinds of quote characters? The main purpose is to create strings con‐

taining quote characters. You can have single quotes inside double-quoted strings, or

double quotes inside single-quoted strings:

```
>>> "'Nay!' said the naysayer. 'Neigh?' said the horse."
"'Nay!' said the naysayer. 'Neigh?' said the horse."
>>> 'The rare double quote in captivity: ".'
'The rare double quote in captivity: ".'
>>> 'A "two by four" is actually 1 1⁄2" × 3 1⁄2".'
'A "two by four" is actually 1 1⁄2" × 3 1⁄2".'
>>> "'There's the man that shot my paw!' cried the limping hound."
"'There's the man that shot my paw!' cried the limping hound."
```
You can also use three single quotes (''') or three double quotes ("""):

```
>>> '''Boom!'''
'Boom'
>>> """Eek!"""
'Eek!'
```
Triple quotes aren’t very useful for short strings like these. Their most common use is

to create multiline strings, like this classic poem from Edward Lear:

```
>>> poem = '''There was a Young Lady of Norway,
... Who casually sat in a doorway;
... When the door squeezed her flat,
```
**64 | Chapter 5: Text Strings**


```
... She exclaimed, "What of that?"
... This courageous Young Lady of Norway.'''
>>>
```
(This was entered in the interactive interpreter, which prompted us with >>> for the

first line and continuation prompts ... until we entered the final triple quotes and

went to the next line.)

If you tried to create that poem without triple quotes, Python would make a fuss

when you went to the second line:

```
>>> poem = 'There was a young lady of Norway,
File "<stdin>", line 1
poem = 'There was a young lady of Norway,
^
SyntaxError: EOL while scanning string literal
>>>
```
If you have multiple lines within triple quotes, the line ending characters will be pre‐

served in the string. If you have leading or trailing spaces, they’ll also be kept:

```
>>> poem2 = '''I do not like thee, Doctor Fell.
... The reason why, I cannot tell.
... But this I know, and know full well:
... I do not like thee, Doctor Fell.
... '''
>>> print (poem2)
I do not like thee, Doctor Fell.
The reason why, I cannot tell.
But this I know, and know full well:
I do not like thee, Doctor Fell.
```
##### >>>

By the way, there’s a difference between the output of print() and the automatic

echoing done by the interactive interpreter:

```
>>> poem2
'I do not like thee, Doctor Fell.\n The reason why, I cannot tell.\n But
this I know, and know full well:\n I do not like thee, Doctor Fell.\n'
```
print() strips quotes from strings and prints their contents. It’s meant for human

output. It helpfully adds a space between each of the things it prints, and a newline at

the end:

```
>>> print ('Give', "us", '''some''', """space""")
Give us some space
```
If you don’t want the space or newline, Chapter 14 explains how to avoid them.

The interactive interpreter prints the string with individual quotes and escape charac‐

ters such as \n, which are explained in “Escape with \” on page 66.

```
Create with Quotes | 65
```

```
>>> """'Guten Morgen, mein Herr!'
... said mad king Ludwig to his wig."""
"'Guten Morgen, mein Herr!'\nsaid mad king Ludwig to his wig."
```
Finally, there is the empty string, which has no characters at all but is perfectly valid.

You can create an empty string with any of the aforementioned quotes:

```
>>> ''
''
>>> ""
''
>>> ''''''
''
>>> """"""
''
>>>
```
### Create with str()

You can make a string from another data type by using the str() function:

```
>>> str(98.6)
'98.6'
>>> str(1.0e4)
'10000.0'
>>> str(True)
'True'
```
Python uses the str() function internally when you call print() with objects that are

not strings and when doing string formatting, which you’ll see later in this chapter.

### Escape with \

Python lets you escape the meaning of some characters within strings to achieve

effects that would otherwise be difficult to express. By preceding a character with a

backslash (\), you give it a special meaning. The most common escape sequence is \n,

which means to begin a new line. With this you can create multiline strings from a

one-line string:

```
>>> palindrome = 'A man, \n A plan, \n A canal: \n Panama.'
>>> print (palindrome)
A man,
A plan,
A canal:
Panama.
```
You will see the escape sequence \t (tab) used to align text:

```
>>> print (' \t abc')
abc
>>> print ('a \t bc')
```
**66 | Chapter 5: Text Strings**


```
a bc
>>> print ('ab \t c')
ab c
>>> print ('abc \t ')
abc
```
(The final string has a terminating tab which, of course, you can’t see.)

You might also need \' or \" to specify a literal single or double quote inside a string

that’s quoted by the same character:

```
>>> testimony = " \" I did nothing! \" he said. \" Or that other thing. \" "
>>> testimony
'"I did nothing!" he said. "Or that other thing."'
>>> print (testimony)
"I did nothing!" he said. "Or that other thing."
```
```
>>> fact = "The world's largest rubber duck was 54'2 \" by 65'7 \" by 105'"
>>> print (fact)
The world's largest rubber duck was 54'2" by 65'7" by 105'
```
And if you need a literal backslash, type two of them (the first escapes the second):

```
>>> speech = 'The backslash ( \\ ) bends over backwards to please you.'
>>> print (speech)
The backslash (\) bends over backwards to please you.
>>>
```
As I mentioned early in this chapter, a raw string negates these escapes:

```
>>> info = r'Type a \n to get a new line in a normal string'
>>> info
'Type a \\n to get a new line in a normal string'
>>> print (info)
Type a \n to get a new line in a normal string
```
(The extra backslash in the first info output was added by the interactive interpreter.)

A raw string does not undo any real (not '\n') newlines:

```
>>> poem = r'''Boys and girls, come out to play.
... The moon doth shine as bright as day.'''
>>> poem
'Boys and girls, come out to play.\nThe moon doth shine as bright as day.'
>>> print (poem)
Boys and girls, come out to play.
The moon doth shine as bright as day.
```
##### | 67


### Combine by Using +

You can combine literal strings or string variables in Python by using the + operator:

```
>>> 'Release the kraken! ' + 'No, wait!'
'Release the kraken! No, wait!'
```
You can also combine literal strings (not string variables) just by having one after the

other:

```
>>> "My word! " "A gentleman caller!"
'My word! A gentleman caller!'
>>> "Alas! ""The kraken!"
'Alas! The kraken!'
```
If you have a lot of these, you can avoid escaping the line endings by surrounding

them with parentheses:

```
>>> vowels = ( 'a'
... "e" '''i'''
... 'o' """u"""
... )
>>> vowels
'aeiou'
```
Python does not add spaces for you when concatenating strings, so in some earlier

examples, we needed to include spaces explicitly. Python does add a space between

each argument to a print() statement and a newline at the end.

```
>>> a = 'Duck.'
>>> b = a
>>> c = 'Grey Duck!'
>>> a + b + c
'Duck.Duck.Grey Duck!'
>>> print (a, b, c)
Duck. Duck. Grey Duck!
```
### Duplicate with *

You use the * operator to duplicate a string. Try typing these lines into your interac‐

tive interpreter and see what they print:

```
>>> start = 'Na ' * 4 + ' \n '
>>> middle = 'Hey ' * 3 + ' \n '
>>> end = 'Goodbye.'
>>> print (start + start + middle + end)
```
Notice that the * has higher precedence than +, so the string is duplicated before the

line feed is tacked on.

**68 | Chapter 5: Text Strings**


### Get a Character with []

To get a single character from a string, specify its offset inside square brackets after

the string’s name. The first (leftmost) offset is 0, the next is 1, and so on. The last

(rightmost) offset can be specified with –1, so you don’t have to count; going to the

left are –2, –3, and so on:

```
>>> letters = 'abcdefghijklmnopqrstuvwxyz'
>>> letters[0]
'a'
>>> letters[1]
'b'
>>> letters[-1]
'z'
>>> letters[-2]
'y'
>>> letters[25]
'z'
>>> letters[5]
'f'
```
If you specify an offset that is the length of the string or longer (remember, offsets go

from 0 to length–1), you’ll get an exception:

```
>>> letters[100]
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
IndexError: string index out of range
```
Indexing works the same with the other sequence types (lists and tuples), which I

cover in Chapter 7.

Because strings are immutable, you can’t insert a character directly into one or change

the character at a specific index. Let’s try to change 'Henny' to 'Penny' and see what

happens:

```
>>> name = 'Henny'
>>> name[0] = 'P'
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```
Instead you need to use some combination of string functions such as replace() or a

slice (which we look at in a moment):

```
>>> name = 'Henny'
>>> name.replace('H', 'P')
'Penny'
>>> 'P' + name[1:]
'Penny'
```
```
Get a Character with [] | 69
```

We didn’t change the value of name. The interactive interpreter just printed the result

of the replacement.

### Get a Substring with a Slice

You can extract a substring (a part of a string) from a string by using a slice. You

define a slice by using square brackets, a _start_ offset, an _end_ offset, and an optional

_step_ count between them. You can omit some of these. The slice will include charac‐

ters from offset _start_ to one before _end_ :

- [:] extracts the entire sequence from start to end.
- [ _start_ :] specifies from the _start_ offset to the end.
- [: _end_ ] specifies from the beginning to the _end_ offset minus 1.
- [ _start_ : _end_ ] indicates from the _start_ offset to the _end_ offset minus 1.
- [ _start_ : _end_ : _step_ ] extracts from the _start_ offset to the _end_ offset minus 1,
    skipping characters by _step_.

As before, offsets go 0, 1, and so on from the start to the right, and –1,–2, and so forth

from the end to the left. If you don’t specify _start_ , the slice uses 0 (the beginning). If

you don’t specify _end_ , it uses the end of the string.

Let’s make a string of the lowercase English letters:

```
>>> letters = 'abcdefghijklmnopqrstuvwxyz'
```
Using a plain : is the same as 0: (the entire string):

```
>>> letters[:]
'abcdefghijklmnopqrstuvwxyz'
```
Here’s an example from offset 20 to the end:

```
>>> letters[20:]
'uvwxyz'
```
Now, from offset 10 to the end:

```
>>> letters[10:]
'klmnopqrstuvwxyz'
```
And another, offset 12 through 14. Python does not include the end offset in the slice.

The start offset is inclusive, and the end offset is exclusive:

```
>>> letters[12:15]
'mno'
```
**70 | Chapter 5: Text Strings**


The three last characters:

```
>>> letters[-3:]
'xyz'
```
In this next example, we go from offset 18 to the fourth before the end; notice the

difference from the previous example, in which starting at –3 gets the x, but ending at

–3 actually stops at –4, the w:

```
>>> letters[18:-3]
'stuvw'
```
In the following, we extract from 6 before the end to 3 before the end:

```
>>> letters[-6:-2]
'uvwx'
```
If you want a step size other than 1, specify it after a second colon, as shown in the

next series of examples.

From the start to the end, in steps of 7 characters:

```
>>> letters[::7]
'ahov'
```
From offset 4 to 19, by 3:

```
>>> letters[4:20:3]
'ehknqt'
```
From offset 19 to the end, by 4:

```
>>> letters[19::4]
'tx'
```
From the start to offset 20 by 5:

```
>>> letters[:21:5]
'afkpu'
```
(Again, the end needs to be one more than the actual offset.)

And that’s not all! Given a negative step size, this handy Python slicer can also step

backward. This starts at the end and ends at the start, skipping nothing:

```
>>> letters[-1::-1]
'zyxwvutsrqponmlkjihgfedcba'
```
It turns out that you can get the same result by using this:

```
>>> letters[::-1]
'zyxwvutsrqponmlkjihgfedcba'
```
Slices are more forgiving of bad offsets than are single-index lookups with []. A slice

offset earlier than the beginning of a string is treated as 0 , and one after the end is

treated as -1, as is demonstrated in this next series of examples.

```
Get a Substring with a Slice | 71
```

From 50 before the end to the end:

```
>>> letters[-50:]
'abcdefghijklmnopqrstuvwxyz'
```
From 51 before the end to 50 before the end:

```
>>> letters[-51:-50]
''
```
From the start to 69 after the start:

```
>>> letters[:70]
'abcdefghijklmnopqrstuvwxyz'
```
From 70 after the start to 70 after the start:

```
>>> letters[70:71]
''
```
### Get Length with len()

So far, we’ve used special punctuation characters such as + to manipulate strings. But

there are only so many of these. Now let’s begin to use some of Python’s built-in func‐

tions: named pieces of code that perform certain operations.

The len() function counts characters in a string:

```
>>> len(letters)
26
>>> empty = ""
>>> len(empty)
0
```
You can use len() with other sequence types, too, as you’ll see in Chapter 7.

### Split with split()

Unlike len(), some functions are specific to strings. To use a string function, type the

name of the string, a dot, the name of the function, and any arguments that the func‐

tion needs: _string_. _function_ ( _arguments_ ). There’s a longer discussion of functions in

Chapter 9.

You can use the built-in string split() function to break a string into a list of smaller

strings based on some separator. We look at lists in Chapter 7. A list is a sequence of

values, separated by commas and surrounded by square brackets:

```
>>> tasks = 'get gloves,get mask,give cat vitamins,call ambulance'
>>> tasks.split(',')
['get gloves', 'get mask', 'give cat vitamins', 'call ambulance']
```
**72 | Chapter 5: Text Strings**


In the preceding example, the string was called tasks and the string function was

called split(), with the single separator argument ','. If you don’t specify a separa‐

tor, split() uses any sequence of white space characters—newlines, spaces, and tabs:

```
>>> tasks.split()
['get', 'gloves,get', 'mask,give', 'cat', 'vitamins,call', 'ambulance']
```
You still need the parentheses when calling split with no arguments—that’s how

Python knows you’re calling a function.

### Combine by Using join()

Not too surprisingly, the join() function is the opposite of split(): it collapses a list

of strings into a single string. It looks a bit backward because you specify the string

that glues everything together first, and then the list of strings to glue:

_string_ .join( _list_ ). So, to join the list lines with separating newlines, you would

say '\n'.join(lines). In the following example, let’s join some names in a list with a

comma and a space:

```
>>> crypto_list = ['Yeti', 'Bigfoot', 'Loch Ness Monster']
>>> crypto_string = ', '.join(crypto_list)
>>> print ('Found and signing book deals:', crypto_string)
Found and signing book deals: Yeti, Bigfoot, Loch Ness Monster
```
### Substitute by Using replace()

You use replace() for simple substring substitution. Give it the old substring, the

new one, and how many instances of the old substring to replace. It returns the

changed string but does not modify the original string. If you omit this final count

argument, it replaces all instances. In this example, only one string ('duck') is

matched and replaced in the returned string:

```
>>> setup = "a duck goes into a bar..."
>>> setup.replace('duck', 'marmoset')
'a marmoset goes into a bar...'
>>> setup
'a duck goes into a bar...'
```
Change up to 100 of them:

```
>>> setup.replace('a ', 'a famous ', 100)
'a famous duck goes into a famous bar...'
```
When you know the exact substring(s) you want to change, replace() is a good

choice. But watch out. In the second example, if we had substituted for the single

character string 'a' rather than the two character string 'a ' (a followed by a space),

we would have also changed a in the middle of other words:

```
Combine by Using join() | 73
```

```
>>> setup.replace('a', 'a famous', 100)
'a famous duck goes into a famous ba famousr...'
```
Sometimes, you want to ensure that the substring is a whole word, or the beginning

of a word, and so on. In those cases, you need regular expressions, which are described

in numbing detail in Chapter 12.

### Strip with strip()

It’s very common to strip leading or trailing “padding” characters from a string, espe‐

cially spaces. The strip() functions shown here assume that you want to get rid of

whitespace characters (' ', '\t', '\n') if you don’t give them an argument. strip()

strips both ends, lstrip() only from the left, and rstrip() only from the right. Let’s

say the string variable world contains the string "earth" floating in spaces:

```
>>> world = " earth "
>>> world.strip()
'earth'
>>> world.strip(' ')
'earth'
>>> world.lstrip()
'earth '
>>> world.rstrip()
' earth'
```
If the character were not there, nothing happens:

```
>>> world.strip('!')
' earth '
```
Besides no argument (meaning whitespace characters) or a single character, you can

also tell strip() to remove any character in a multicharacter string:

```
>>> blurt = "What the...!!?"
>>> blurt.strip('.?!')
'What the'
```
Appendix E shows some definitions of character groups that are useful with strip():

```
>>> import string
>>> string.whitespace
' \t\n\r\x0b\x0c'
>>> string.punctuation
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
>>> blurt = "What the...!!?"
>>> blurt.strip(string.punctuation)
'What the'
>>> prospector = "What in tarnation ...??!!"
>>> prospector.strip(string.whitespace + string.punctuation)
'What in tarnation'
```
**74 | Chapter 5: Text Strings**


### Search and Select

Python has a large set of string functions. Let’s explore how the most common of

them work. Our test subject is the following string containing the text of the immor‐

tal poem “What Is Liquid?” by Margaret Cavendish, Duchess of Newcastle:

```
>>> poem = '''All that doth flow we cannot liquid name
... Or else would fire and water be the same;
... But that is liquid which is moist and wet
... Fire that property can never get.
... Then 'tis not cold that doth the fire put out
... But 'tis the wet that makes it die, no doubt.'''
```
Inspiring!

To begin, get the first 13 characters (offsets 0 to 12):

```
>>> poem[:13]
'All that doth'
```
How many characters are in this poem? (Spaces and newlines are included in the

count.)

```
>>> len(poem)
250
```
Does it start with the letters All?

```
>>> poem.startswith('All')
True
```
Does it end with That's all, folks!?

```
>>> poem.endswith('That \' s all, folks!')
False
```
Python has two methods (find() and index()) for finding the offset of a substring,

and has two versions of each (starting from the beginning or the end). They work the

same if the substring is found. If it isn’t, find() returns -1, and index() raises an

exception.

Let’s find the offset of the first occurrence of the word the in the poem:

```
>>> word = 'the'
>>> poem.find(word)
73
>>> poem.index(word)
73
```
And the offset of the last the:

```
>>> word = 'the'
>>> poem.rfind(word)
214
```
```
Search and Select | 75
```

```
>>> poem.rindex(word)
214
```
But if the substring isn’t in there:

```
>>> word = "duck"
>>> poem.find(word)
-1
>>> poem.rfind(word)
-1
>>> poem.index(word)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: substring not found
>>> poem.rfind(word)
-1
>>> poem.rindex(word)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: substring not found
```
How many times does the three-letter sequence the occur?

```
>>> word = 'the'
>>> poem.count(word)
3
```
Are all of the characters in the poem either letters or numbers?

```
>>> poem.isalnum()
False
```
Nope, there were some punctuation characters.

### Case

In this section, we look at some more uses of the built-in string functions. Our test

string is again the following:

```
>>> setup = 'a duck goes into a bar...'
```
Remove. sequences from both ends:

```
>>> setup.strip('.')
'a duck goes into a bar'
```
```
Because strings are immutable, none of these examples actually
changes the setup string. Each example just takes the value of
setup, does something to it, and returns the result as a new string.
```
Capitalize the first word:

**76 | Chapter 5: Text Strings**


```
>>> setup.capitalize()
'A duck goes into a bar...'
```
Capitalize all the words:

```
>>> setup.title()
'A Duck Goes Into A Bar...'
```
Convert all characters to uppercase:

```
>>> setup.upper()
'A DUCK GOES INTO A BAR...'
```
Convert all characters to lowercase:

```
>>> setup.lower()
'a duck goes into a bar...'
```
Swap uppercase and lowercase:

```
>>> setup.swapcase()
'A DUCK GOES INTO A BAR...'
```
### Alignment

Now, let’s work with some layout alignment functions. The string is aligned within

the specified total number of spaces ( 30 here).

Center the string within 30 spaces:

```
>>> setup.center(30)
' a duck goes into a bar... '
```
Left justify:

```
>>> setup.ljust(30)
'a duck goes into a bar... '
```
Right justify:

```
>>> setup.rjust(30)
' a duck goes into a bar...'
```
Next, we look at more ways to align a string.

### Formatting

You’ve seen that you can concatenate strings by using +. Let’s look at how to interpo‐

late data values into strings using various formats. You can use this to produce

reports, forms, and other outputs where appearances need to be just so.

Besides the functions in the previous section, Python has three ways of formatting

strings:

```
Alignment | 77
```

- old style (supported in Python 2 and 3)
- new style (Python 2.6 and up)
- f-strings (Python 3.6 and up)

#### Old style: %

The old style of string formatting has the form _format_string_ % _data_. Inside the for‐

mat string are interpolation sequences. Table 5-1 illustrates that the very simplest

sequence is a % followed by a letter indicating the data type to be formatted.

Table 5-1. Conversion types

```
%s string
%d decimal integer
%x hex integer
%o octal integer
%f decimal float
%e exponential float
%g decimal or exponential float
%% a literal %
```
You can use a %s for any data type, and Python will format it as a string with no extra

spaces.

Following are some simple examples. First, an integer:

```
>>> '%s' % 42
'42'
>>> '%d' % 42
'42'
>>> '%x' % 42
'2a'
>>> '%o' % 42
'52'
```
A float:

```
>>> '%s' % 7.03
'7.03'
>>> '%f' % 7.03
'7.030000'
>>> '%e' % 7.03
'7.030000e+00'
>>> '%g' % 7.03
'7.03'
```
**78 | Chapter 5: Text Strings**


An integer and a literal %:

```
>>> '%d%%' % 100
'100%'
```
Let’s try some string and integer interpolation:

```
>>> actor = 'Richard Gere'
>>> cat = 'Chester'
>>> weight = 28
```
```
>>> "My wife's favorite actor is %s" % actor
"My wife's favorite actor is Richard Gere"
```
```
>>> "Our cat %s weighs %s pounds" % (cat, weight)
'Our cat Chester weighs 28 pounds'
```
That %s inside the string means to interpolate a string. The number of % appearances

in the string needs to match the number of data items after the % that follows the

string. A single data item such as actor goes right after that final %. Multiple data

must be grouped into a tuple (details in Chapter 7; it’s bounded by parentheses, sepa‐

rated by commas) such as (cat, weight).

Even though weight is an integer, the %s inside the string converted it to a string.

You can add other values in the format string between the % and the type specifier to

designate minimum and maximum widths, alignment, and character filling. This is a

little language in its own right, and more limited than the one in the next two sec‐

tions. Let’s take a quick look at these values:

- An initial '%' character.
- An optional alignment character: nothing or '+' means right-align, and '-'
    means left-align.
- An optional minwidth field width to use.
- An optional '.' character to separate minwidth and maxchars.
- An optional maxchars (if conversion type is s) saying how many characters to
    print from the data value. If the conversion type is f, this specifies precision (how
    many digits to print after the decimal point).
- The conversion type character from the earlier table.

This is confusing, so here are some examples for a string:

```
>>> thing = 'woodchuck'
>>> '%s' % thing
'woodchuck'
>>> '%12s' % thing
' woodchuck'
>>> '%+12s' % thing
```
```
Formatting | 79
```

```
' woodchuck'
>>> '%-12s' % thing
'woodchuck '
>>> '%.3s' % thing
'woo'
>>> '%12.3s' % thing
' woo'
>>> '%-12.3s' % thing
'woo '
```
Once more with feeling, and a float with %f variants:

```
>>> thing = 98.6
>>> '%f' % thing
'98.600000'
>>> '%12f' % thing
' 98.600000'
>>> '%+12f' % thing
' +98.600000'
>>> '%-12f' % thing
'98.600000 '
>>> '%.3f' % thing
'98.600'
>>> '%12.3f' % thing
' 98.600'
>>> '%-12.3f' % thing
'98.600 '
```
And an integer with %d:

```
>>> thing = 9876
>>> '%d' % thing
'9876'
>>> '%12d' % thing
' 9876'
>>> '%+12d' % thing
' +9876'
>>> '%-12d' % thing
'9876 '
>>> '%.3d' % thing
'9876'
>>> '%12.3d' % thing
' 9876'
>>> '%-12.3d' % thing
'9876 '
```
For an integer, the %+12d just forces the sign to be printed, and the format strings

with .3 in them have no effect as they do for a float.

#### New style: {} and format()

Old style formatting is still supported. In Python 2, which will freeze at version 2.7, it

will be supported forever. For Python 3, use the “new style” formatting described in

**80 | Chapter 5: Text Strings**


this section. If you have Python 3.6 or newer, f-strings (“Newest Style: f-strings” on

page 82) are even better.

“New style” formatting has the form _format_string_ .format( _data_ ).

The format string is not exactly the same as the one in the previous section. The sim‐

plest usage is demonstrated here:

```
>>> thing = 'woodchuck'
>>> '{}'.format(thing)
'woodchuck'
```
The arguments to the format() function need to be in the order as the {} placehold‐

ers in the format string:

```
>>> thing = 'woodchuck'
>>> place = 'lake'
>>> 'The {} is in the {}.'.format(thing, place)
'The woodchuck is in the lake.'
```
With new-style formatting, you can also specify the arguments by position like this:

```
>>> 'The {1} is in the {0}.'.format(place, thing)
'The woodchuck is in the lake.'
```
The value 0 referred to the first argument, place, and 1 referred to thing.

The arguments to format() can also be named arguments

```
>>> 'The {thing} is in the {place}'.format(thing='duck', place='bathtub')
'The duck is in the bathtub'
```
or a dictionary:

```
>>> d = {'thing': 'duck', 'place': 'bathtub'}
```
```
Formatting | 81
```

In the following example, {0} is the first argument to format() (the dictionary d):

```
>>> 'The {0[thing]} is in the {0[place]}.'.format(d)
'The duck is in the bathtub.'
```
These examples all printed their arguments with default formats. New-style format‐

ting has a slightly different format string definition from the old-style one (examples

follow):

- An initial colon (':').
- An optional fill character (default ' ') to pad the value string if it’s shorter than
    minwidth.
- An optional alignment character. This time, left alignment is the default. '<' also
    means left, '>' means right, and '^' means center.
- An optional sign for numbers. Nothing means only prepend a minus sign ('-')
    for negative numbers. ' ' means prepend a minus sign for negative numbers,
    and a space (' ') for positive ones.
- An optional minwidth. An optional period ('.') to separate minwidth and max‐
    chars.
- An optional maxchars.
- The conversion type.

```
>>> thing = 'wraith'
>>> place = 'window'
>>> 'The {} is at the {}'.format(thing, place)
'The wraith is at the window'
>>> 'The {:10s} is at the {:10s}'.format(thing, place)
'The wraith is at the window '
>>> 'The {:<10s} is at the {:<10s}'.format(thing, place)
'The wraith is at the window '
>>> 'The {:^10s} is at the {:^10s}'.format(thing, place)
'The wraith is at the window '
>>> 'The {:>10s} is at the {:>10s}'.format(thing, place)
'The wraith is at the window'
>>> 'The {:!^10s} is at the {:!^10s}'.format(thing, place)
'The !!wraith!! is at the !!window!!'
```
#### Newest Style: f-strings

f-strings appeared in Python 3.6, and are now the recommended way of formatting

strings.

To make an f-string:

- Type the letter f or F directly before the initial quote.

**82 | Chapter 5: Text Strings**


- Include variable names or expressions within curly brackets ({}) to get their val‐
    ues into the string.

It’s like the previous section’s “new-style” formatting, but without the format() func‐

tion, and without empty brackets ({}) or positional ones ({1}) in the format string.

```
>>> thing = 'wereduck'
>>> place = 'werepond'
>>> f'The {thing} is in the {place}'
'The wereduck is in the werepond'
```
As I already mentioned, expressions are also allowed inside the curly brackets:

```
>>> f'The {thing.capitalize()} is in the {place.rjust(20)}'
'The Wereduck is in the werepond'
```
This means that the things that you could do inside format() in the previous section,

you can now do inside a {} in your main string. This seems easier to read.

f-strings use the same formatting language (width, padding, alignment) as new-style

formatting, after a ':'.

```
>>> f'The {thing:>20} is in the {place:.^20}'
'The wereduck is in the ......werepond......'
```
Starting in Python 3.8, f-strings gain a new shortcut that’s helpful when you want to

print variable names as well as their values. This is handy when debugging. The trick

is to have a single = after the name in the {}-enclosed part of the f-string:

```
>>> f'{thing =}, {place =}'
thing = 'wereduck', place = 'werepond'
```
The name can actually be an expression, and it will be printed literally:

```
>>> f'{thing[-4:] =}, {place.title() =}'
thing[-4:] = 'duck', place.title() = 'Werepond'
```
Finally, the = can be followed by a : and the formatting arguments like width and

alignment:

```
>>> f'{thing = :>4.4}'
thing = 'were'
```
### More String Things

Python has many more string functions than I’ve shown here. Some will turn up in

later chapters (especially Chapter 12), but you can find all the details at the standard

documentation link.

```
More String Things | 83
```

### Coming Up

You’ll find Froot Loops at the grocery store, but Python loops are at the first counter

in the next chapter.

### Things to Do

5.1 Capitalize the word starting with m:

```
>>> song = """When an eel grabs your arm,
... And it causes great harm,
... That's - a moray!"""
```
5.2 Print each list question with its correctly matching answer, in the form:

Q: question

A: answer

```
>>> questions = [
... "We don't serve strings around here. Are you a string?",
... "What is said on Father's Day in the forest?",
... "What makes the sound 'Sis! Boom! Bah!'?"
... ]
>>> answers = [
... "An exploding sheep.",
... "No, I'm a frayed knot.",
... "'Pop!' goes the weasel."
... ]
```
5.3 Write the following poem by using old-style formatting. Substitute the strings

'roast beef', 'ham', 'head', and 'clam' into this string:

```
My kitty cat likes %s,
My kitty cat likes %s,
My kitty cat fell on his %s
And now thinks he's a %s.
```
5.4 Write a form letter by using new-style formatting. Save the following string as

letter (you’ll use it in the next exercise):

```
Dear {salutation} {name},
```
```
Thank you for your letter. We are sorry that our {product}
{verbed} in your {room}. Please note that it should never
be used in a {room}, especially near any {animals}.
```
```
Send us your receipt and {amount} for shipping and handling.
We will send you another {product} that, in our tests,
is {percent}% less likely to have {verbed}.
```
```
Thank you for your support.
```
**84 | Chapter 5: Text Strings**


```
Sincerely,
{spokesman}
{job_title}
```
5.5 Assign values to variable strings named 'salutation', 'name', 'product',

'verbed' (past tense verb), 'room', 'animals', 'percent', 'spokesman', and

'job_title'. Print letter with these values, using letter.format().

5.6 After public polls to name things, a pattern emerged: an English submarine

(Boaty McBoatface), an Australian racehorse (Horsey McHorseface), and a Swedish

train (Trainy McTrainface). Use % formatting to print the winning name at the state

fair for a prize duck, gourd, and spitz.

5.7 Do the same, with format() formatting.

5.8 Once more, with feeling, and f strings.

```
Things to Do | 85
```


**CHAPTER 6**

**Loop with while and for**

```
For a’ that, an’ a’ that, Our toils obscure, an’ a’ that ...
—Robert Burns, For a’ That and a’ That
```
Testing with if, elif, and else runs from top to bottom. Sometimes, we need to do

something more than once. We need a loop, and Python gives us two choices: while

and for.

### Repeat with while

The simplest looping mechanism in Python is while. Using the interactive inter‐

preter, try this example, which is a simple loop that prints the numbers from 1 to 5:

```
>>> count = 1
>>> while count <= 5:
... print (count)
... count += 1
...
1
2
3
4
5
>>>
```
We first assigned the value 1 to count. The while loop compared the value of count

to 5 and continued if count was less than or equal to 5. Inside the loop, we printed the

value of count and then incremented its value by one with the statement count += 1.

Python goes back to the top of the loop, and again compares count with 5. The value

of count is now 2 , so the contents of the while loop are again executed, and count is

incremented to 3.

##### 87


This continues until count is incremented from 5 to 6 at the bottom of the loop. On

the next trip to the top, count <= 5 is now False, and the while loop ends. Python

moves on to the next lines.

#### Cancel with break

If you want to loop until something occurs, but you’re not sure when that might hap‐

pen, you can use an infinite loop with a break statement. This time, let’s read a line of

input from the keyboard via Python’s input() function and then print it with the first

letter capitalized. We break out of the loop when a line containing only the letter q is

typed:

```
>>> while True:
... stuff = input("String to capitalize [type q to quit]: ")
... if stuff == "q":
... break
... print (stuff.capitalize())
```
```
String to capitalize [type q to quit]: test
Test
String to capitalize [type q to quit]: hey, it works
Hey, it works
String to capitalize [type q to quit]: q
>>>
```
#### Skip Ahead with continue

Sometimes, you don’t want to break out of a loop but just want to skip ahead to the

next iteration for some reason. Here’s a contrived example: let’s read an integer, print

its square if it’s odd, and skip it if it’s even. We even added a few comments. Again, we

use q to stop the loop:

```
>>> while True:
... value = input("Integer, please [q to quit]: ")
... if value == 'q': # quit
... break
... number = int(value)
... if number % 2 == 0: # an even number
... continue
... print (number, "squared is", number*number)
...
Integer, please [q to quit]: 1
1 squared is 1
Integer, please [q to quit]: 2
Integer, please [q to quit]: 3
3 squared is 9
Integer, please [q to quit]: 4
Integer, please [q to quit]: 5
5 squared is 25
```
**88 | Chapter 6: Loop with while and for**


```
Integer, please [q to quit]: q
>>>
```
#### Check break Use with else

If the while loop ended normally (no break call), control passes to an optional else.

You use this when you’ve coded a while loop to check for something, and breaking as

soon as it’s found. The else would be run if the while loop completed but the object

was not found:

```
>>> numbers = [1, 3, 5]
>>> position = 0
>>> while position < len(numbers):
... number = numbers[position]
... if number % 2 == 0:
... print ('Found even number', number)
... break
... position += 1
... else : # break not called
... print ('No even number found')
```
```
No even number found
```
```
This use of else might seem nonintuitive. Consider it a break
checker.
```
### Iterate with for and in

Python makes frequent use of iterators, for good reason. They make it possible for

you to traverse data structures without knowing how large they are or how they are

implemented. You can even iterate over data that is created on the fly, allowing pro‐

cessing of data streams that would otherwise not fit in the computer’s memory all at

once.

To show iteration, we need something to iterate over. You’ve already seen strings in

Chapter 5, but have not yet read the details on other iterables like lists and tuples

(Chapter 7) or dictionaries (Chapter 8). I’ll show two ways to walk through a string

here, and show iteration for the other types in their own chapters.

```
Iterate with for and in | 89
```

It’s legal Python to step through a string like this:

```
>>> word = 'thud'
>>> offset = 0
>>> while offset < len(word):
... print (word[offset])
... offset += 1
```
```
t
h
u
d
```
But there’s a better, more Pythonic way:

```
>>> for letter in word:
... print (letter)
```
```
t
h
u
d
```
String iteration produces one character at a time.

#### Cancel with break

A break in a for loop breaks out of the loop, as it does for a while loop:

```
>>> word = 'thud'
>>> for letter in word:
... if letter == 'u':
... break
... print (letter)
```
```
t
h
```
#### Skip with continue

Inserting a continue in a for loop jumps to the next iteration of the loop, as it does

for a while loop.

#### Check break Use with else

Similar to while, for has an optional else that checks whether the for completed

normally. If break was not called, the else statement is run.

**90 | Chapter 6: Loop with while and for**


This is useful when you want to verify that the previous for loop ran to completion

instead of being stopped early with a break:

```
>>> word = 'thud'
>>> for letter in word:
... if letter == 'x':
... print ("Eek! An 'x'!")
... break
... print (letter)
... else :
... print ("No 'x' in there.")
```
```
t
h
u
d
No 'x' in there.
```
```
As with while, the use of else with for might seem nonintuitive. It
makes more sense if you think of the for as looking for something,
and else being called if you didn’t find it. To get the same effect
without else, use some variable to indicate whether you found
what you wanted in the for loop.
```
#### Generate Number Sequences with range()

The range() function returns a stream of numbers within a specified range. without

first having to create and store a large data structure such as a list or tuple. This lets

you create huge ranges without using all the memory in your computer and crashing

your program.

You use range() similar to how to you use slices: range( _start_ , _stop_ , _step_ ). If you

omit _start_ , the range begins at 0. The only required value is _stop_ ; as with slices, the

last value created will be just before _stop_. The default value of _step_ is 1 , but you can

go backward with -1.

Like zip(), range() returns an iterable object, so you need to step through the values

with for ... in, or convert the object to a sequence like a list. Let’s make the range

0, 1, 2:

```
>>> for x in range(0,3):
... print (x)
...
0
1
2
>>> list( range(0, 3) )
[0, 1, 2]
```
```
Iterate with for and in | 91
```

Here’s how to make a range from 2 down to 0 :

```
>>> for x in range(2, -1, -1):
... print (x)
```
```
2
1
0
>>> list( range(2, -1, -1) )
[2, 1, 0]
```
The following snippet uses a step size of 2 to get the even numbers from 0 to 10 :

```
>>> list( range(0, 11, 2) )
[0, 2, 4, 6, 8, 10]
```
### Other Iterators

Chapter 14 shows iteration over files. In Chapter 10, you can see how to enable itera‐

tion over objects that you’ve defined yourself. Also, Chapter 11 talks about itertools

—a standard Python module with many useful shortcuts.

### Coming Up

Chain individual data into lists and tuples.

### Things to Do

6.1 Use a for loop to print the values of the list [3, 2, 1, 0].

6.2 Assign the value 7 to the variable guess_me, and the value 1 to the variable num

ber. Write a while loop that compares number with guess_me. Print 'too low' if num

ber is less than guess me. If number equals guess_me, print 'found it!' and then

exit the loop. If number is greater than guess_me, print 'oops' and then exit the loop.

Increment number at the end of the loop.

6.3 Assign the value 5 to the variable guess_me. Use a for loop to iterate a variable

called number over range(10). If number is less than guess_me, print 'too low'. If it

equals guess_me, print found it! and then break out of the for loop. If number is

greater than guess_me, print 'oops' and then exit the loop.

**92 | Chapter 6: Loop with while and for**