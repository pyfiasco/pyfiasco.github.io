

## Introducing Python : Bill Lubanovic

Modern Computing in Simple Packages

```
Second
Edition
```


## Table of Contents

**Preface...................................................................... xxi**


- 1. A Taste of Py. Part I. Python Basics
   - Mysteries
   - Little Programs
   - A Bigger Program
   - Python in the Real World
   - Python Versus the Language from Planet X
   - Why Python?
   - Why Not Python?
   - Python 2 Versus Python
   - Installing Python
   - Running Python
      - Using the Interactive Interpreter
      - Using Python Files
      - What’s Next?
   - Your Moment of Zen
   - Coming Up
   - Things to Do
- 2. Data: Types, Values, Variables, and Names.
   - Python Data Are Objects
   - Types
   - Mutability
   - Literal Values
   - Variables
   - Assignment
   - Variables Are Names, Not Places
   - Assigning to Multiple Names
   - Reassigning a Name
   - Copying
   - Choose Good Variable Names
   - Coming Up
   - Things to Do
- 3. Numbers.
   - Booleans
   - Integers
      - Literal Integers
      - Integer Operations
      - Integers and Variables
      - Precedence
      - Bases
      - Type Conversions
      - How Big Is an int?
   - Floats
   - Math Functions
   - Coming Up
   - Things to Do

=====================================================================================================================

### PART I

**Python Basics**



**CHAPTER 1**

**A Taste of Py**

```
Only ugly languages become popular. Python is the one exception.
—Don Knuth
```
### Mysteries

Let’s begin with two mini-mysteries and their solutions. What do you think the fol‐

lowing two lines mean?

```
(Row 1): (RS) K18,ssk,k1,turn work.
(Row 2): (WS) Sl 1 pwise,p5,p2tog,p1,turn.
```
It looks technical, like some kind of computer program. Actually, it’s a knitting pat‐

tern; specifically, a fragment describing how to turn the heel of a sock, like the one in

Figure 1-1.

Figure 1-1. Knitted socks

##### 3


```
1 Usually only found in cookbooks and cozy mysteries.
```
This makes as much sense to me as a Sudoku puzzle does to one of my cats, but my

wife understands it perfectly. If you’re a knitter, you do, too.

Let’s try another mysterious text, found on an index card. You’ll figure out its purpose

right away, although you might not know its final product:

```
1/2 c. butter or margarine
1/2 c. cream
2 1/2 c. flour
1 t. salt
1 T. sugar
4 c. riced potatoes (cold)
```
```
Be sure all ingredients are cold before adding flour.
Mix all ingredients.
Knead thoroughly.
Form into 20 balls. Store cold until the next step.
For each ball:
Spread flour on cloth.
Roll ball into a circle with a grooved rolling pin.
Fry on griddle until brown spots appear.
Turn over and fry other side.
```
Even if you don’t cook, you probably recognized that it’s a recipe^1 : a list of food ingre‐

dients followed by directions for preparation. But what does it make? It’s lefse, a Nor‐

wegian delicacy that resembles a tortilla (Figure 1-2). Slather on some butter and jam

or whatever you like, roll it up, and enjoy.

Figure 1-2. Lefse

**4 | Chapter 1: A Taste of Py**


The knitting pattern and the recipe share some features:

- A regular vocabulary of words, abbreviations, and symbols. Some might be famil‐
    iar, others mystifying.
- Rules about what can be said, and where—syntax.
- A sequence of operations to be performed in order.
- Sometimes, a repetition of some operations (a loop), such as the method for fry‐
    ing each piece of lefse.
- Sometimes, a reference to another sequence of operations (in computer terms, a
    function). In the recipe, you might need to refer to another recipe for ricing pota‐
    toes.
- Assumed knowledge about the context. The recipe assumes you that know what
    water is and how to boil it. The knitting pattern assumes that you can knit and
    purl without stabbing yourself too often.
- Some data to be used, created, or modified—potatoes and yarn.
- The tools used to work with the data—pots, mixers, ovens, knitting sticks.
- An expected result. In our examples, something for your feet and something for
    your stomach. Just don’t mix them up.

Whatever you call them—idioms, jargon, little languages—you see examples of them

everywhere. The lingo saves time for people who know it, while mystifying the rest of

us. Try deciphering a newspaper column about bridge if you don’t play the game, or a

scientific paper if you’re not a scientist (or even if you are, but in a different field).

### Little Programs

You’ll see all of these ideas in computer programs, which are themselves like little lan‐

guages, specialized for humans to tell computers what to do. I used the knitting pat‐

tern and recipe to demonstrate that programming isn’t that mysterious. It’s largely a

matter of learning the right words and the rules.

Now, it helps greatly if there aren’t too many words and rules, and if you don’t need to

learn too many of them at once. Our brains can hold only so much at one time.

Let’s finally see a real computer program (Example 1-1). What do you think this does?

Example 1-1. countdown.py

**for** countdown **in** 5, 4, 3, 2, 1, "hey!":
**print** (countdown)

```
Little Programs | 5
```

If you guessed that it’s a Python program that prints the lines

```
5
4
3
2
1
hey!
```
then you know that Python can be easier to learn than a recipe or knitting pattern.

And you can practice writing Python programs from the comfort and safety of your

desk, far from the hazards of hot water and pointy sticks.

The Python program has some special words and symbols—for, in, print, commas,

colons, parentheses, and so on—that are important parts of the language’s syntax

(rules). The good news is that Python has a nicer syntax, and less of it to remember,

than most computer languages. It seems more natural—almost like a recipe.

Example 1-2 is another tiny Python program; it selects one Harry Potter spell from a

Python list and prints it.

Example 1-2. spells.py

spells = [
"Riddikulus!",
"Wingardium Leviosa!",
"Avada Kedavra!",
"Expecto Patronum!",
"Nox!",
"Lumos!",
]
**print** (spells[3])

The individual spells are Python strings (sequences of text characters, enclosed in

quotes). They’re separated by commas and enclosed in a Python list that’s defined by

enclosing square brackets ([ and ]). The word spells is a variable that gives the list a

name so that we can do things with it. In this case, the program would print the

fourth spell:

```
Expecto Patronum!
```
Why did we say 3 if we wanted the fourth? A Python list such as spells is a sequence

of values, accessed by their offset from the beginning of the list. The first value is at

offset 0 , and the fourth value is at offset 3.

**6 | Chapter 1: A Taste of Py**


```
People count from 1, so it might seem weird to count from 0. It
helps to think in terms of offsets instead of positions. Yes, this is an
example of how computer programs sometimes differ from com‐
mon language usage.
```
Lists are very common data structures in Python, and Chapter 7 shows how to use

them.

The program in Example 1-3 prints a quote from one of the Three Stooges, but refer‐

enced by who said it rather than its position in a list.

Example 1-3. quotes.py

quotes = {
"Moe": "A wise guy, huh?",
"Larry": "Ow!",
"Curly": "Nyuk nyuk!",
}
stooge = "Curly"
**print** (stooge, "says:", quotes[stooge])

If you were to run this little program, it would print the following:

```
Curly says: Nyuk nyuk!
```
quotes is a variable that names a Python dictionary—a collection of unique keys (in

this example, the name of the Stooge) and associated values (here, a notable saying of

that Stooge). Using a dictionary, you can store and look up things by name, which is

often a useful alternative to a list.

The spells example used square brackets ([ and ]) to make a Python list, and the

quotes example uses curly brackets ({ and }, which are no relation to Curly), to make

a Python dictionary. Also, a colon (:) is used to associate each key in the dictionary

with its value. You can read much more about dictionaries in Chapter 8.

That wasn’t too much syntax at once, I hope. In the next few chapters, you’ll

encounter more of these little rules, a bit at a time.

### A Bigger Program

And now for something completely different: Example 1-4 presents a Python pro‐

gram performing a more complex series of tasks. Don’t expect to understand how the

program works yet; that’s what this book is for! The intent is to introduce you to the

look and feel of a typical nontrivial Python program. If you know other computer

languages, evaluate how Python compares. Even without knowing Python yet, can

you roughly figure out what each line does before reading the explanation after the

```
A Bigger Program | 7
```

program? You’ve already seen examples of a Python list and a dictionary, and this

throws in a few more features.

In earlier printings of this book, the sample program connected to a YouTube website

and retrieved information on its most highly rated videos, like “Charlie Bit My Fin‐

ger.” It worked well until shortly after the ink was dry on the second printing. That’s

when Google dropped support for this service and the marquee sample program

stopped working. Our new Example 1-4 goes to another site which should be around

longer—the Wayback Machine at the Internet Archive, a free service that has saved

billions of web pages (and movies, TV shows, music, games, and other digital arti‐

facts) over 20 years. You’ll see more examples of such web APIs in Chapter 18.

The program will ask you to type a URL and a date. Then, it asks the Wayback

Machine if it has a copy of that website around that date. If it found one, it returns the

information to this Python program, which prints the URL and displays it in your

web browser. The point is to show how Python handles a variety of tasks—get your

typed input, communicate across the internet to a website, get back some content,

extract a URL from it, and convince your web browser to display that URL.

If we got back a normal web page full of HTML-formatted text, we would need to

figure out how to display it, which is a lot of work that we happily entrust to web

browsers. We could also try to extract the parts that we want (see more details about

web scraping in Chapter 18). Either choice would be more work and a larger program.

Instead, the Wayback Machine returns data in JSON format. JSON (JavaScript Object

Notation) is a human-readable text format that describes the types, values, and order

of the data within it. It’s another little language, and it has become a popular way to

exchange data among different computer languages and systems. You’ll read more

about JSON in Chapter 12.

Python programs can translate JSON text into Python data structures—the kind you’ll

see in the next few chapters—as though you wrote a program to create them yourself.

Our little program just selects one piece (the URL of the old page from the Internet

Archive website). Again, this is a complete Python program that you can run your‐

self. We’ve included only a little error-checking, just to keep the example short. The

line numbers are not part of the program; they are included to help you follow the

description that we provide after the program.

Example 1-4. archive.py

1 **import webbrowser**
2 **import json**
3 **from urllib.request import** urlopen
4
5 **print** ("Let's find an old website.")
6 site = input("Type a website URL: ")
7 era = input("Type a year, month, and day, like 20150613: ")

**8 | Chapter 1: A Taste of Py**


8 url = "http://archive.org/wayback/available?url=%s&timestamp=%s" % (site, era)
9 response = urlopen(url)
10 contents = response.read()
11 text = contents.decode("utf-8")
12 data = json.loads(text)
13 **try** :
14 old_site = data["archived_snapshots"]["closest"]["url"]
15 **print** ("Found this copy: ", old_site)
16 **print** ("It should appear in your browser now.")
17 webbrowser.open(old_site)
18 **except** :
19 **print** ("Sorry, no luck finding", site)

This little Python program did a lot in a few fairly readable lines. You don’t know all

these terms yet, but you will within the next few chapters. Here’s what’s going on in

each line:

1. Import (make available to this program) all the code from the Python standard
    library module called webbrowser.
2. Import all the code from the Python standard library module called json.
3. Import only the urlopen function from the standard library module url
    lib.request.
4. A blank line, because we don’t want to feel crowded.
5. Print some initial text to your display.
6. Print a question about a URL, read what you type, and save it in a program vari‐
    able called site.
7. Print another question, this time reading a year, month, and day, and then save it
    in a variable called era.
8. Construct a string variable called url to make the Wayback Machine look up its
    copy of the site and date that you typed.
9. Connect to the web server at that URL and request a particular web service.
10. Get the response data and assign to the variable contents.
11. Decode contents to a text string in JSON format, and assign to the variable text.
12. Convert text to data—Python data structures.
13. Error-checking: try to run the next four lines, and if any fail, run the last line of

the program (after the except).

14. If we got back a match for this site and date, extract its value from a three-level

```
Python dictionary. Notice that this line and the next two are indented. That’s how
Python knows that they go with the preceding try line.
```
15. Print the URL that we found.

```
A Bigger Program | 9
```

16. Print what will happen after the next line executes.
17. Display the URL we found in your web browser.
18. If anything failed in the previous four lines, Python jumps down to here.
19. If it failed, print a message and the site that we were looking for. This is indented

because it should be run only if the preceding except line runs.

When I ran this in a terminal window, I typed a site URL and a date, and got this text

output:

```
$ python archive.py
Let's find an old website.
Type a website URL: lolcats.com
Type a year, month, and day, like 20150613: 20151022
Found this copy: http://web.archive.org/web/20151102055938/http://www.lolcats.com/
It should appear in your browser now.
```
And Figure 1-3 shows what appeared in my browser.

Figure 1-3. From the Wayback Machine

In the previous example, we used some of Python’s standard library modules (pro‐

grams that are included with Python when it’s installed), but there’s nothing sacred

about them. Python has a trove of excellent third-party software. Example 1-5 is a

**10 | Chapter 1: A Taste of Py**


rewrite that accesses the Internet Archive website with an external Python software

package called requests.

Example 1-5. archive2.py

1 **import webbrowser**
2 **import requests**
3
4 **print** ("Let's find an old website.")
5 site = input("Type a website URL: ")
6 era = input("Type a year, month, and day, like 20150613: ")
7 url = "http://archive.org/wayback/available?url=%s&timestamp=%s" % (site, era)
8 response = requests.get(url)
9 data = response.json()
10 **try** :
11 old_site = data["archived_snapshots"]["closest"]["url"]
12 **print** ("Found this copy: ", old_site)
13 **print** ("It should appear in your browser now.")
14 webbrowser.open(old_site)
15 **except** :
16 **print** ("Sorry, no luck finding", site)

The new version is shorter, and I’d guess it’s more readable for most people. You’ll

read more about requests in Chapter 18, and externally authored Python software in

general in Chapter 11.

### Python in the Real World

So, is learning Python worth the time and effort? Python has been around since 1991

(older than Java, younger than C), and is consistently in the top five most popular

computing languages. People are paid to write Python programs—serious stuff that

you use every day, such as Google, YouTube, Instagram, Netflix, and Hulu. I’ve used it

for production applications in many areas. Python has a reputation for productivity

that appeals to fast-moving organizations.

You’ll find Python in many computing environments, including these:

- The command line in a monitor or terminal window
- Graphical user interfaces (GUIs), including the web
- The web, on the client and server sides
- Backend servers supporting large popular sites
- The cloud (servers managed by third parties)
- Mobile devices
- Embedded devices

```
Python in the Real World | 11
```

Python programs range from one-off scripts—such as those you’ve seen so far in this

chapter—to million-line systems.

The 2018 Python Developers’ Survey has numbers and graphs on Python’s current

place in the computing world.

We’ll look at its uses in websites, system administration, and data manipulation. In

the final chapters, we’ll see specific uses of Python in the arts, science, and business.

### Python Versus the Language from Planet X

How does Python compare against other languages? Where and when would you

choose one over the other? In this section, I show code samples from other languages,

just so you can see what the competition looks like. You are not expected to under‐

stand these if you haven’t worked with them. (By the time you get to the final Python

sample, you might be relieved that you haven’t had to work with some of the others.)

Each program is supposed to print a number and say a little about the language.

If you use a terminal or terminal window, the program that reads what you type, runs

it, and displays the results is called the shell program. The Windows shell is called

cmd; it runs batch files with the suffix .bat. Linux and other Unix-like systems

(including macOS) have many shell programs. The most popular is called bash or sh.

The shell has simple abilities, such as simple logic and expanding wildcard symbols

such as * into filenames. You can save commands in files called shell scripts and run

them later. These might be the first programs you encountered as a programmer. The

problem is that shell scripts don’t scale well beyond a few hundred lines, and they are

much slower than the alternative languages. The next snippet shows a little shell pro‐

gram:

```
#!/bin/sh
language=0
echo "Language $language: I am the shell. So there."
```
If you saved this in a file as test.sh and ran it with sh test.sh, you would see the

following on your display:

```
Language 0: I am the shell. So there.
```
Old stalwarts C and C++ are fairly low-level languages, used when speed is most

important. Your operating system and many of its programs (including the python

program on your computer) are probably written in C or C++.

These two are harder to learn and maintain. You need to keep track of many details

like memory management, which can lead to program crashes and problems that are

difficult to diagnose. Here’s a little C program:

**12 | Chapter 1: A Taste of Py**


```
#include <stdio.h>
int main(int argc, char *argv[]) {
int language = 1;
printf("Language %d: I am C! See? Si!\n", language);
return 0;
}
```
C++ has the C family resemblance but has evolved some distinctive features:

```
#include <iostream>
using namespace std;
int main() {
int language = 2;
cout << "Language " << language << \
": I am C++! Pay no attention to my little brother!" << \
endl;
return(0);
}
```
Java and C# are successors to C and C++ that avoid some of their forebears’ problems

—especially memory management—but can be somewhat verbose. The example that

follows shows some Java:

```
public class Anecdote {
public static void main (String[] args) {
int language = 3;
System.out.format("Language %d: I am Java! So there!\n", language);
}
}
```
If you haven’t written programs in any of these languages, you might wonder: what is

all that stuff? We only wanted to print a simple line. Some languages carry substantial

syntactic baggage. You’ll learn more about this in Chapter 2.

C, C++, and Java are examples of static languages. They require you to specify some

low-level details like data types for the computer. Appendix A shows how a data type

like an integer has a specific number of bits in your computer, and can only do

integer-ey things. In contrast, dynamic languages (also called scripting languages) do

not force you to declare variable types before using them.

The all-purpose dynamic language for many years was Perl. Perl is very powerful and

has extensive libraries. Yet, its syntax can be awkward, and the language seems to

have lost momentum in the past few years to Python and Ruby. This example regales

you with a Perl bon mot:

```
my $language = 4;
print "Language $language: I am Perl, the camel of languages.\n";
```
Ruby is a more recent language. It borrows a little from Perl, and is popular mostly

because of Ruby on Rails, a web development framework. It’s used in many of the

```
Python Versus the Language from Planet X | 13
```

same areas as Python, and the choice of one or the other might boil down to a matter

of taste, or available libraries for your particular application. Here’s a Ruby snippet:

```
language = 5
puts "Language #{language}: I am Ruby, ready and aglow."
```
PHP, which you can see in the example that follows, is very popular for web develop‐

ment because it makes it easy to combine HTML and code. However, the PHP lan‐

guage itself has a number of gotchas, and PHP has not caught on as a general

language outside of the web. Here’s what it looks like:

```
<?PHP
$language = 6;
echo "Language $language: I am PHP, a language and palindrome.\n";
?>
```
Go (or Golang, if you’re trying to Google it) is a recent language that tries to be both

efficient and friendly:

```
package main
```
```
import "fmt"
```
```
func main() {
language := 7
fmt.Printf("Language %d: Hey, ho, let's Go!\n", language)
}
```
Another modern alternative to C and C++ is Rust:

```
fn main() {
println!("Language {}: Rust here!", 8)
```
Who’s left? Oh yes, Python:

```
language = 9
print (f"Language {language}: I am Python. What's for supper?")
```
### Why Python?

One reason, not necessarily the most important, is popularity. By various measures,

Python is:

- The fastest-growing major programming language, as you can see in Figure 1-4.
- The editors of the June 2019 TIOBE Index say: “This month Python has reached
    again an all time high in TIOBE index of 8.5%. If Python can keep this pace, it
    will probably replace C and Java in 3 to 4 years time, thus becoming the most
    popular programming language of the world.”
- Programming language of the year for 2018 (TIOBE), and top ranking by IEEE
    Spectrum and PyPL.

**14 | Chapter 1: A Taste of Py**


- The most popular language for introductory computer science courses at the top
    American colleges.
- The official teaching language for high schools in France.

Figure 1-4. Python leads in major programming language growth

More recently, it’s become extremely popular in the data science and machine learn‐

ing worlds. If you want to land a well-paying programming job in an interesting area,

Python is a good choice now. And if you’re hiring, there’s a growing pool of experi‐

enced Python developers.

But why is it popular? Programming languages don’t exactly exude charisma. What

are some underlying reasons?

Python is a good general-purpose, high-level language. Its design makes it very reada‐

ble, which is more important than it sounds. Every computer program is written only

once, but read and revised many times, often by many people. Being readable also

makes it easier to learn and remember; hence, more writable. Compared with other

```
Why Python? | 15
```

popular languages, Python has a gentle learning curve that makes you productive

sooner, yet it has depths that you can explore as you gain expertise.

Python’s relative terseness makes it possible for you to write programs that are

smaller than their equivalents in a static language. Studies have shown that program‐

mers tend to produce roughly the same number of lines of code per day—regardless

of the language—so, halving the lines of code doubles your productivity, just like that.

Python is the not-so-secret weapon of many companies that think this is important.

And of course, Python is free, as in beer (price) and speech (liberty). Write anything

you want with Python, and use it anywhere, freely. No one can read your Python pro‐

gram and say, “That’s a nice little program you have there. It would be a shame if

something happened to it.”

Python runs almost everywhere and has “batteries included”—a metric boatload of

useful software in its standard library. This book presents many examples of the stan‐

dard library and useful third-party Python code.

But, maybe the best reason to use Python is an unexpected one: people generally

enjoy programming with it rather than seeing it as a necessary evil to get stuff done. It

doesn’t get in the way. A familiar quote is that it “fits your brain.” Often, developers

will say that they miss some Python design when they need to work in another lan‐

guage. And that separates Python from most of its peers.

### Why Not Python?

Python isn’t the best language for every situation.

It is not installed everywhere by default. Appendix B shows you how to install Python

if you don’t already have it on your computer.

It’s fast enough for most applications, but it might not be fast enough for some of the

more demanding ones. If your program spends most of its time calculating things

(the technical term is CPU-bound), a program written in C, C++, C#, Java, Rust, or

Go will generally run faster than its Python equivalent. But not always!

**16 | Chapter 1: A Taste of Py**


Here are some solutions:

- Sometimes a better algorithm (a stepwise solution) in Python beats an inefficient
    one in C. The greater speed of development in Python gives you more time to
    experiment with alternatives.
- In many applications (notably, the web), a program twiddles its gossamer thumbs
    while awaiting a response from some server across a network. The CPU (central
    processing unit, the computer’s chip that does all the calculating) is barely
    involved; consequently, end-to-end times between static and dynamic programs
    will be close.
- The standard Python interpreter is written in C and can be extended with C
    code. I discuss this a little in Chapter 19.
- Python interpreters are becoming faster. Java was terribly slow in its infancy, and
    a lot of research and money went into speeding it up. Python is not owned by a
    corporation, so its enhancements have been more gradual. In “PyPy” on page
    444 , I talk about the PyPy project and its implications.
- You might have an extremely demanding application, and no matter what you
    do, Python doesn’t meet your needs. The usual alternatives are C, C++, and Java.
    Go (which feels like Python but performs like C) or Rust could also be worth a
    look.

### Python 2 Versus Python 3

One medium-sized complication is that there are two versions of Python out there.

Python 2 has been around forever and is preinstalled on Linux and Apple computers.

It has been an excellent language, but nothing’s perfect. In computer languages, as in

many other areas, some mistakes are cosmetic and easy to fix, whereas others are

hard. Hard fixes are incompatible: new programs written with them will not work on

the old Python system, and old programs written before the fix will not work on the

new system.

Python’s creator (Guido van Rossum) and others decided to bundle the hard fixes

together, and introduced them as Python 3 in 2008. Python 2 is the past, and Python

3 is the future. The final version of Python 2 is 2.7, and it will be around for while, but

it’s the end of the line; there will be no Python 2.8. The end of Python 2 language sup‐

port is in January of 2020. Security and other fixes will no longer be made, and many

prominent Python packages will drop support for Python 2 by then. Operating sys‐

tems will soon either drop Python 2 or make 3 their new default. Conversion of pop‐

ular Python software to Python 3 had been gradual, but we’re now well past the

tipping point. All new development will be in Python 3.

```
Python 2 Versus Python 3 | 17
```

This book is about Python 3. It looks almost identical to Python 2. The most obvious

change is that print is a function in Python 3, so you need to call it with parentheses

surrounding its arguments. The most important change is the handling of Unicode

characters, which is covered in Chapter 12. I point out other significant differences as

they come up.

### Installing Python

Rather than cluttering this chapter, you can find the details on how to install Python

3 in Appendix B. If you don’t have Python 3, or aren’t sure, go there and see what you

need to do for your computer. Yes, this is a pain in the wazoo (specifically, the right-

anterior wazoo), but you’ll need to do it only once.

### Running Python

After you have installed a working copy of Python 3, you can use it to run the Python

programs in this book as well as your own Python code. How do you actually run a

Python program? There are two main ways:

- Python’s built-in interactive interpreter (also called its shell) is the easy way to
    experiment with small programs. You type commands line by line and see the
    results immediately. With the tight coupling between typing and seeing, you can
    experiment faster. I’ll use the interactive interpreter to demonstrate language fea‐
    tures, and you can type the same commands in your own Python environment.
- For everything else, store your Python programs in text files, normally with
    the .py extension, and run them by typing python followed by those filenames.

Let’s try both methods now.

#### Using the Interactive Interpreter

Most of the code examples in this book use the built-in interactive interpreter. When

you type the same commands as you see in the examples and get the same results,

you’ll know you’re on the right track.

You start the interpreter by typing just the name of the main Python program on

your computer: it should be python, python3, or something similar. For the rest of

this book, we assume it’s called python; if yours has a different name, type that wher‐

ever you see python in a code example.

The interactive interpreter works almost exactly the same as Python works on files,

with one exception: when you type something that has a value, the interactive inter‐

preter prints its value for you automatically. This isn’t a part of the Python language,

just a feature of the interpreter to save you from typing print() all the time. For

**18 | Chapter 1: A Taste of Py**


```
2 If you’re not sure what this means, see Appendix B for details for different operating systems.
```
example, if you start Python and type the number 27 in the interpreter, it will be ech‐

oed to your terminal (if you have the line 27 in a file, Python won’t get upset, but you

won’t see anything print when you run the program):

```
$ python
Python 3.7.2 (v3.7.2:9a3ffc0492, Dec 24 2018, 02:44:43)
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> 27
27
```
```
In the preceding example, $ is a sample system prompt for you to
type a command like python in the terminal window. We use it for
the code examples in this book, although your prompt might be
different.
```
By the way, print() also works within the interpreter whenever you want to print

something:

```
>>> print (27)
27
```
If you tried these examples with the interactive interpreter and saw the same results,

you just ran some real (though tiny) Python code. In the next few chapters, you’ll

graduate from one-liners to longer Python programs.

#### Using Python Files

If you put 27 in a file by itself and run it through Python, it will run, but it won’t print

anything. In normal noninteractive Python programs, you need to call the print

function to print things:

```
print (27)
```
Let’s make a Python program file and run it:

1. Open your text editor.
2. Type the line print(27), as it appears here.
3. Save this to a file called test.py. Make sure you save it as plain text rather than a
    “rich” format such as RTF or Word. You don’t need to use the .py suffix for your
    Python program files, but it does help you remember what they are.
4. If you’re using a GUI—that’s almost everyone—open a terminal window.^2

```
Running Python | 19
```

5. Run your program by typing the following:

```
$ python test.py
```
You should see a single line of output:

```
27
```
Did that work? If it did, congratulations on running your first standalone Python

program.

#### What’s Next?

You’ll be typing commands to an actual Python system, and they need to follow legal

Python syntax. Rather than dumping the syntax rules on you all at once, we stroll

through them over the next few chapters.

The basic way to develop Python programs is by using a plain-text editor and a ter‐

minal window. I use plain-text displays in this book, sometimes showing interactive

terminal sessions and sometimes pieces of Python files. You should know that there

are also many good integrated development environments (IDEs) for Python. These

may feature GUIs with advanced text editing and help displays. You can learn about

details for some of these in Chapter 19.

### Your Moment of Zen

Each computing language has its own style. In the Preface, I mentioned that there is

often a Pythonic way to express yourself. Embedded in Python is a bit of free verse

that expresses the Python philosophy succinctly (as far as I know, Python is the only

language to include such an Easter egg). Just type import this into your interactive

interpreter and then press the Enter key whenever you need this moment of Zen:

```
>>> import this
The Zen of Python, by Tim Peters
```
```
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one--and preferably only one--obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
```
**20 | Chapter 1: A Taste of Py**


```
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea--let's do more of those!
```
I’ll bring up examples of these sentiments throughout the book.

### Coming Up

The next chapter talks about Python data types and variables. This will prepare you

for the following chapters, which delve into Python’s data types and code structures in

detail.

### Things to Do

This chapter was an introduction to the Python language—what it does, how it looks,

and where it fits in the computing world. At the end of each chapter, I suggest some

mini-projects to help you remember what you just read and prepare you for what’s to

come.

1.1 If you don’t already have Python 3 installed on your computer, do it now. Read

Appendix B for the details for your computer system.

1.2 Start the Python 3 interactive interpreter. Again, details are in Appendix B. It

should print a few lines about itself and then a single line starting with >>>. That’s

your prompt to type Python commands.

1.3 Play with the interpreter a little. Use it like a calculator and type this: 8 * 9. Press

the Enter key to see the result. Python should print 72.

1.4 Type the number 47 and press the Enter key. Did it print 47 for you on the next

line?

1.5 Now, type print(47) and press Enter. Did that also print 47 for you on the next

line?

```
Coming Up | 21
```


**CHAPTER 2**

**Data: Types, Values, Variables, and Names**

```
A good name is rather to be chosen than great riches.
—Proverbs 22:1
```
Under the hood, everything in your computer is just a sequence of bits (see Appen‐

dix A). One of the insights of computing is that we can interpret those bits any way

we want—as data of various sizes and types (numbers, text characters) or even as

computer code itself. We use Python to define chunks of these bits for different pur‐

poses, and to get them to and from the CPU.

We begin with Python’s data types and the values that they can contain. Then we see

how to represent data as literal values and variables.

### Python Data Are Objects

You can visualize your computer’s memory as a long series of shelves. Each slot on

one of those memory shelves is one byte wide (eight bits), and slots are numbered

from 0 (the first) to the end. Modern computers have billions of bytes of memory

(gigabytes), so the shelves would fill a huge imaginary warehouse.

A Python program is given access to some of your computer’s memory by your oper‐

ating system. That memory is used for the code of the program itself, and the data

that it uses. The operating system ensures that the program cannot read or write

other memory locations without somehow getting permission.

Programs keep track of where (memory location) their bits are, and what (data type)

they are. To your computer, it’s all just bits. The same bits mean different things,

depending on what type we say they are. The same bit pattern might stand for the

integer 65 or the text character A.

```
Data: Types, Values, Variables, and Names | 23
```

Different types may use different numbers of bits. When you read about a “64-bit

machine,” this means that an integer uses 64 bits (8 bytes).

Some languages plunk and pluck these raw values in memory, keeping track of their

sizes and types. Instead of handling such raw data values directly, Python wraps each

data value—booleans, integers, floats, strings, even large data structures, functions,

and programs—in memory as an object. There’s a whole chapter (Chapter 10) on how

to define your own objects in Python. For now, we’re just talking about objects that

handle the basic built-in data types.

Using the memory shelves analogy, you can think of objects as variable-sized boxes

occupying spaces on those shelves, as shown in Figure 2-1. Python makes these object

boxes, puts them in empty spaces on the shelves, and removes them when they’re no

longer used.

Figure 2-1. An object is like a box; this one is an integer with value _7_

In Python, an object is a chunk of data that contains at least the following:

- A type that defines what it can do (see the next section)
- A unique id to distinguish it from other objects
- A value consistent with its type
- A reference count that tracks how often this object is used

Its id is like its location on the shelf, a unique identifier. Its type is like a factory stamp

on the box, saying what it can do. If a Python object is an integer, it has the type int,

and could (among other things, which you’ll see in Chapter 3) be added to another

int. If we picture the box as being made of clear plastic, we can see the value inside.

You’ll learn the use of the reference count a few sections from now, when we talk about

variables and names.

**24 | Chapter 2: Data: Types, Values, Variables, and Names**


### Types

Table 2-1 shows the basic data types in Python. The second column (Type) contains

the Python name of that type. The third column (Mutable?) indicates whether the

value can be changed after creation, which I explain more in the next section. Exam‐

ples shows one or more literal examples of that type. And the final column (Chapter)

points you to the chapter in this book with the most details on this type.

Table 2-1. Python’s basic data types

```
Name Type Mutable? Examples Chapter
Boolean bool no True, False Chapter 3
Integer int no 47 , 25000 , 25_000 Chapter 3
Floating point float no 3.14, 2.7e5 Chapter 3
Complex complex no 3j, 5 + 9j Chapter 22
Text string str no 'alas', "alack", '''a verse attack''' Chapter 5
List list yes ['Winken', 'Blinken', 'Nod'] Chapter 7
Tuple tuple no (2, 4, 8) Chapter 7
Bytes bytes no b'ab\xff' Chapter 12
ByteArray bytearray yes bytearray(...) Chapter 12
Set set yes set([3, 5, 7]) Chapter 8
Frozen set frozenset no frozenset(['Elsa', 'Otto']) Chapter 8
Dictionary dict yes {'game': 'bingo', 'dog': 'dingo', 'drum
mer': 'Ringo'}
```
```
Chapter 8
```
After the chapters on these basic data types, you’ll see how to make new types in

Chapter 10.

### Mutability

```
Nought may endure but Mutability.
```
```
—Percy Shelley
```
The type also determines whether the data value contained by the box can be changed

(mutable) or is constant (immutable). Think of an immutable object as a sealed box,

but with clear sides, like Figure 2-1; you can see the value but you can’t change it. By

the same analogy, a mutable object is like a box with a lid: not only can you see the

value inside, you can also change it; however, you can’t change its type.

Python is strongly typed, which means that the type of an object does not change,

even if its value is mutable (Figure 2-2).

##### 25


Figure 2-2. Strong typing does not mean push the keys harder

### Literal Values

There are two ways of specifying data values in Python:

- Literal
- Variable

In coming chapters, you’ll see the details on how to specify literal values for different

data types—integers are a sequence of digits, floats contain a decimal point, text

strings are surrounded by quotes, and so on. But, for the rest of this chapter, to avoid

calloused fingertips, our examples will use only short decimal integers and a Python

list or two. Decimal integers are just like integers in math: a sequence of digits from 0

to 9. There are a few extra integer details (like signs and nondecimal bases) that we

look at in Chapter 3.

### Variables

Now, we’ve arrived at a key concept in computing languages.

Python, like most computer languages, lets you define variables—names for values in

your computer’s memory that you want to use in a program.

**26 | Chapter 2: Data: Types, Values, Variables, and Names**


```
1 async and await are new in Python 3.7.
```
Python variable names have some rules:

- They can contain only these characters:

—Lowercase letters (a through z)

—Uppercase letters (A through Z)

—Digits ( 0 through 9 )

—Underscore (_)

- They are case-sensitive: thing, Thing, and THING are different names.
- They must begin with a letter or an underscore, not a digit.
- Names that begin with an underscore are treated specially (which you can read
    about in Chapter 9).
- They cannot be one of Python’s reserved words (also known as keywords).

The reserved words^1 are:

```
False await else import pass
None break except in raise
True class finally is return
and continue for lambda try
as def from nonlocal while
assert del global not with
async elif if or yield
```
Within a Python program, you can find the reserved words with

```
>>> help("keywords")
```
or:

```
>>> import keyword
>>> keyword.kwlist
```
These are valid names:

- a
- a1
- a_b_c___95
- _abc
- _1a

```
Variables | 27
```

These names, however, are not valid:

- 1
- 1a
- 1_
- name!
- another-name

### Assignment

In Python, you use = to assign a value to a variable.

```
We all learned in grade school arithmetic that = means equal to. So
why do many computer languages, including Python, use = for
assignment? One reason is that standard keyboards lack logical
alternatives such as a left arrow key, and = didn’t seem too confus‐
ing. Also, in computer programs you use assignment much more
than you test for equality.
```
Programs are not like algebra. When you learned math in school, you saw equations

like this:

```
y = x + 12
```
You would solve the equation by “plugging in” a value for x. If you gave x the value 5 ,

5 + 12 is 17 , so the value of y would be 17. Plug in 6 for x to get 18 for y, and so on.

Computer program lines may look like equations, but their meaning is different. In

Python and other computer languages, x and y are variables. Python knows that a

bare sequence of digits like 12 or 5 is a literal integer. So here’s a tiny Python program

that mimics this equation, printing the resulting value of y:

```
>>> x = 5
>>> y = x + 12
>>> y
17
```
Here’s the big difference between math and programs: in math, = means equality of

both sides, but in programs it means assignment: assign the value on the right side to

the variable on the left side.

Also in programs, everything on the right side needs to have a value (this is called

being initialized). The right side can be a literal value, or a variable that has already

been assigned a value, or a combination. Python knows that 5 and 12 are literal

**28 | Chapter 2: Data: Types, Values, Variables, and Names**


integers. The first line assigns the integer value 5 to the variable x. Now we can use

the variable x in the next line. When Python reads y = x + 12, it does the following:

- Sees the = in the middle
- Knows that this is an assignment
- Calculates the right side (gets the value of the object referred to by x and adds it
    to 12 )
- Assigns the result to the left-side variable, y

Then typing the name of the variable y (in the interactive interpreter) will print its

new value.

If you started your program with the line y = x + 12, Python would generate an

exception (an error), because the variable x doesn’t have a value yet:

```
>>> y = x + 12
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
```
You’ll get the full rundown on exceptions in Chapter 9. In computerese, we’d say that

this x was uninitialized.

In algebra, you can work backward, and assign a value to y to calculate x. To do this

in Python, you’d need to get the literal values and initialized variables on the right

side before assigning to x on the left:

```
>>> y = 5
>>> x = 12 - y
>>> x
7
```
### Variables Are Names, Not Places

Now it’s time to make a crucial point about variables in Python: variables are just

names. This is different from many other computer languages, and a key thing to

know about Python, especially when we get to mutable objects like lists. Assignment

does not copy a value; it just attaches a name to the object that contains the data. The

name is a reference to a thing rather than the thing itself. Visualize a name as a tag

with a string attached to the object box somewhere else in the computer’s memory

(Figure 2-3).

```
Variables Are Names, Not Places | 29
```

Figure 2-3. Names point to objects (variable _a_ points to an integer object with value _7_ )

In other languages, the variable itself has a type, and binds to a memory location. You

can change the value at that location, but it needs to be of the same type. This is why

static languages make you declare the types of variables. Python doesn’t, because a

name can refer to anything, and we get the value and type by “following the string” to

the data object itself. This saves time, but there are some downsides:

- You may misspell a variable and get an exception because it doesn’t refer to any‐
    thing, and Python doesn’t automatically check this as static languages do. Chap‐
    ter 19 shows ways of checking your variables ahead of time to avoid this.
- Python’s raw speed is slower than a language like C. It makes the computer do
    more work so you don’t have to.

Try this with the interactive interpreter (visualized in Figure 2-4):

1. As before, assign the value 7 to the name a. This creates an object box containing
    the integer value 7.
2. Print the value of a.
3. Assign a to b, making b also point to the object box containing 7.
4. Print the value of b:

```
>>> a = 7
>>> print (a)
7
>>> b = a
```
**30 | Chapter 2: Data: Types, Values, Variables, and Names**


```
>>> print (b)
7
```
Figure 2-4. Copying a name (now variable _b_ also points to the same integer object)

In Python, if you want to know the type of anything (a variable or a literal value), you

can use type( _thing_ ). type() is one of Python’s built-in functions. If you want to

check whether a variable points to an object of a specific type, use isinstance( _type_ ):

```
>>> type(7)
<class 'int'>
>>> type(7) == int
True
>>> isinstance(7, int)
True
```
```
When I mention a function, I’ll put parentheses (()) after it to
emphasize that it’s a function rather than a variable name or some‐
thing else.
```
Let’s try it with more literal values ( 58 , 99.9, 'abc') and variables (a, b):

```
>>> a = 7
>>> b = a
>>> type(a)
<class 'int'>
>>> type(b)
<class 'int'>
>>> type(58)
```
```
Variables Are Names, Not Places | 31
```

```
2 Or the Island of Misfit Objects.
```
```
<class 'int'>
>>> type(99.9)
<class 'float'>
>>> type('abc')
<class 'str'>
```
A class is the definition of an object; Chapter 10 covers classes in greater detail. In

Python, “class” and “type” mean pretty much the same thing.

As you’ve seen, when you use a variable in Python, it looks up the object that it refers

to. Behind the scenes, Python is busy, often creating temporary objects that will be

discarded a line or two later.

Let’s repeat an earlier example:

```
>>> y = 5
>>> x = 12 - y
>>> x
7
```
In this code snippet, Python did the following:

- Created an integer object with the value 5
- Made a variable y point to that 5 object
- Incremented the reference count of the object with value 5
- Created another integer object with the value 12
- Subtracted the value of the object that y points to ( 5 ) from the value 12 in the
    (anonymous) object with that value
- Assigned this value ( 7 ) to a new (so far, unnamed) integer object
- Made the variable x point to this new object
- Incremented the reference count of this new object that x points to
- Looked up the value of the object that x points to ( 7 ) and printed it

When an object’s reference count reaches zero, no names are pointing to it, so it

doesn’t need to stick around. Python has a charmingly named garbage collector that

reuses the memory of things that are no longer needed. Picture someone behind

those memory shelves, yanking obsolete boxes for recycling.

In this case, we no longer need the objects with the values 5 , 12 , or 7 , or the variables

x and y. The Python garbage collector may choose to send them to object heaven,^2 or

**32 | Chapter 2: Data: Types, Values, Variables, and Names**


keep some around for performance reasons given that small integers tend to be used

a lot.

### Assigning to Multiple Names

You can assign a value to more than one variable name at the same time:

```
>>> two = deux = zwei = 2
>>> two
2
>>> deux
2
>>> zwei
2
```
### Reassigning a Name

Because names point to objects, changing the value assigned to a name just makes the

name point to a new object. The reference count of the old object is decremented, and

the new one’s is incremented.

### Copying

As you saw in Figure 2-4, assigning an existing variable a to a new variable named b

just makes b point to the same object that a does. If you pick up either the a or b tag

and follow their strings, you’ll get to the same object.

If the object is immutable (like an integer), its value can’t be changed, so both names

are essentially read-only. Try this:

```
>>> x = 5
>>> x
5
>>> y = x
>>> y
5
>>> x = 29
>>> x
29
>>> y
5
```
When we assigned x to y, that made the name y point to the integer object with value

5 that x was also pointing to. Changing x made it point to a new integer object with

value 29. It did not change the one containing 5 , which y still points to.

```
Assigning to Multiple Names | 33
```

But if both names point to a mutable object, you can change the object’s value via

either name, and you’ll see the changed value when you use either name. If you didn’t

know this first, it could surprise you.

A list is a mutable array of values, and Chapter 7 covers them in gruesome detail. For

this example, a and b each point to a list with three integer members:

```
>>> a = [2, 4, 6]
>>> b = a
>>> a
[2, 4, 6]
>>> b
[2, 4, 6]
```
These list members (a[0], a[1], and a[2]) are themselves like names, pointing to

integer objects with the values 2 , 4 , and 6. The list object keeps its members in order.

Now change the first list element, through the name a, and see that b also changed:

```
>>> a[0] = 99
>>> a
[99, 4, 6]
>>> b
[99, 4, 6]
```
When the first list element is changed, it no longer points to the object with value 2 ,

but a new object with value 99. The list is still of type list, but its value (the list ele‐

ments and their order) is mutable.

### Choose Good Variable Names

```
He said true things, but called them by wrong names.
—Elizabeth Barrett Browning
```
It’s surprising how important it is to choose good names for your variables. In many

of the code examples so far, I’ve been using throwaway names like a and x. In real

programs, you’ll have many more variables to keep track of at once, and you’ll need

to balance brevity and clarity. For example, it’s faster to type num_loons rather than

number_of_loons or gaviidae_inventory, but it’s more explanatory than n.

**34 | Chapter 2: Data: Types, Values, Variables, and Names**


```
38 looks like a snowman!
```
### Coming Up

Numbers! They’re as exciting as you expect. Well, maybe not that bad.^3 You’ll see how

to use Python as a calculator and how a cat founded a digital system.

### Things to Do

2.1 Assign the integer value 99 to the variable prince, and print it.

2.2 What type is the value 5?

2.3 What type is the value 2.0?

2.4 What type is the expression 5 + 2.0?

```
Coming Up | 35
```


**CHAPTER 3**

**Numbers**

```
That action is best which procures the greatest happiness for the greatest numbers.
—Francis Hutcheson
```
In this chapter we begin by looking at Python’s simplest built-in data types:

- Booleans (which have the value True or False)
- Integers (whole numbers such as 42 and 100000000 )
- Floats (numbers with decimal points such as 3.14159, or sometimes exponents
    like 1.0e8, which means one times ten to the eighth power, or 100000000.0)

In a way, they’re like atoms. We use them individually in this chapter, and in later

chapters you’ll see how to combine them into larger “molecules” like lists and

dictionaries.

Each type has specific rules for its usage and is handled differently by the computer. I

also show how to use literal values like 97 and 3.1416, and the variables that I men‐

tioned in Chapter 2.

The code examples in this chapter are all valid Python, but they’re snippets. We’ll be

using the Python interactive interpreter, typing these snippets and seeing the results

immediately. Try running them yourself with the version of Python on your com‐

puter. You’ll recognize these examples by the >>> prompt.

```
Numbers | 37
```

### Booleans

In Python, the only values for the boolean data type are True and False. Sometimes,

you’ll use these directly; other times you’ll evaluate the “truthiness” of other types

from their values. The special Python function bool() can convert any Python data

type to a boolean.

Functions get their own chapter in Chapter 9, but for now you just need to know that

a function has a name, zero or more comma-separated input arguments surrounded

by parentheses, and zero or more return values. The bool() function takes any value

as its argument and returns the boolean equivalent.

Nonzero numbers are considered True:

```
>>> bool(True)
True
>>> bool(1)
True
>>> bool(45)
True
>>> bool(-45)
True
```
And zero-valued ones are considered False:

```
>>> bool(False)
False
>>> bool(0)
False
>>> bool(0.0)
False
```
You’ll see the usefulness of booleans in Chapter 4. In later chapters, you’ll see how

lists, dictionaries, and other types can be considered True or False.

### Integers

Integers are whole numbers—no fractions, no decimal points, nothing fancy. Well,

aside from a possible initial sign. And bases, if you want to express numbers in other

ways than the usual decimal (base 10).

#### Literal Integers

Any sequence of digits in Python represents a literal integer:

```
>>> 5
5
```
```
38
```
**38 | Chapter 3: Numbers**


```
1 For Python 3.6 and newer.
```
A plain zero ( 0 ) is valid:

```
>>> 0
0
```
But you can’t have an initial 0 followed by a digit between 1 and 9 :

```
>>> 05
File "<stdin>", line 1
05
^
SyntaxError: invalid token
```
```
This Python exception warns that you typed something that breaks
Python’s rules. I explain what this means in “Bases” on page 44.
You’ll see many more examples of exceptions in this book because
they’re Python’s main error handling mechanism.
```
You can start an integer with 0b, 0o, or 0x. See “Bases” on page 44.

A sequence of digits specifies a positive integer. If you put a + sign before the digits,

the number stays the same:

```
>>> 123
123
>>> +123
123
```
To specify a negative integer, insert a – before the digits:

```
>>> -123
-123
```
You can’t have any commas in the integer:

```
>>> 1,000,000
(1, 0, 0)
```
Instead of a million, you’d get a tuple (see Chapter 7 for more information on tuples)

with three values. But you can use the underscore (_) character as a digit separator:^1

```
>>> million = 1_000_000
>>> million
1000000
```
```
Integers | 39
```

Actually, you can put underscores anywhere after the first digit; they’re just ignored:

```
>>> 1_2_3
123
```
#### Integer Operations

For the next few pages, I show examples of Python acting as a simple calculator. You

can do normal arithmetic with Python by using the math operators in this table:

```
Operator Description Example Result
+ Addition 5 + 8 13
```
- Subtraction 90 - 10 80
* Multiplication 4 * 7 28
/ Floating-point division 7 / 2 3.5
// Integer (truncating) division 7 // 2 3
% Modulus (remainder) 7 % 3 1
** Exponentiation 3 ** 4 81

Addition and subtraction work as you’d expect:

```
>>> 5 + 9
14
>>> 100 - 7
93
>>> 4 - 10
-6
```
You can include as many numbers and operators as you’d like:

```
>>> 5 + 9 + 3
17
>>> 4 + 3 - 2 - 1 + 6
10
```
Note that you’re not required to have a space between each number and operator:

```
>>> 5+9 + 3
17
```
It just looks better stylewise and is easier to read.

Multiplication is also straightforward:

```
>>> 6 * 7
42
>>> 7 * 6
42
```
**40 | Chapter 3: Numbers**


##### >>> 6 * 7 * 2 * 3

##### 252

Division is a little more interesting because it comes in two flavors:

- / carries out floating-point (decimal) division
- // performs integer (truncating) division

Even if you’re dividing an integer by an integer, using a / will give you a floating-

point result (floats are coming later in this chapter):

```
>>> 9 / 5
1.8
```
Truncating integer division returns an integer answer, throwing away any remainder:

```
>>> 9 // 5
1
```
Instead of tearing a hole in the space-time continuum, dividing by zero with either

kind of division causes a Python exception:

```
>>> 5 / 0
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 7 // 0
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by z
```
#### Integers and Variables

All of the preceding examples used literal integers. You can mix literal integers and

variables that have been assigned integer values:

```
>>> a = 95
>>> a
95
>>> a - 3
92
```
You’ll remember from Chapter 2 that a is a name that points to an integer object.

When I said a - 3, I didn’t assign the result back to a, so the value of a did not

change:

```
>>> a
95
```
```
Integers | 41
```

If you wanted to change a, you would do this:

```
>>> a = a - 3
>>> a
92
```
Again, this would not be a legal math equation, but it’s how you reassign a value to a

variable in Python. In Python, the expression on the right side of the = is calculated

first, and then assigned to the variable on the left side.

If it helps, think of it this way:

- Subtract 3 from a
- Assign the result of that subtraction to a temporary variable
- Assign the value of the temporary variable to a:

```
>>> a = 95
>>> temp = a - 3
>>> a = temp
```
So, when you say

```
>>> a = a - 3
```
Python is calculating the subtraction on the righthand side, remembering the result,

and then assigning it to a on the left side of the + sign. It’s faster and neater than using

a temporary variable.

You can combine the arithmetic operators with assignment by putting the operator

before the =. Here, a -= 3 is like saying a = a - 3:

```
>>> a = 95
>>> a -= 3
>>> a
92
```
This is like a = a + 8:

```
>>> a = 92
>>> a += 8
>>> a
100
```
And this is like a = a * 2:

```
>>> a = 100
>>> a *= 2
>>> a
200
```
**42 | Chapter 3: Numbers**


Here’s a floating-point division example, like a = a / 3:

```
>>> a = 200
>>> a /= 3
>>> a
66.66666666666667
```
Now let’s try the shorthand for a = a // 4 (truncating integer division):

```
>>> a = 13
>>> a //= 4
>>> a
3
```
The % character has multiple uses in Python. When it’s between two numbers, it pro‐

duces the remainder when the first number is divided by the second:

```
>>> 9 % 5
4
```
Here’s how to get both the (truncated) quotient and remainder at once:

```
>>> divmod(9,5)
(1, 4)
```
Otherwise, you could have calculated them separately:

```
>>> 9 // 5
1
>>> 9 % 5
4
```
You just saw some new things here: a function named divmod is given the integers 9

and 5 and returns a two-item tuple. As I mentioned earlier, tuples will take a bow in

Chapter 7; functions debut in Chapter 9.

One last math feature is exponentiation with **, which also lets you mix integers and

floats:

```
>>> 2**3
8
>>> 2.0 ** 3
8.0
>>> 2 ** 3.0
8.0
>>> 0 ** 3
0
```
#### Precedence

What would you get if you typed the following?

```
>>> 2 + 3 * 4
```
```
Integers | 43
```

If you do the addition first, 2 + 3 is 5 , and 5 * 4 is 20. But if you do the multiplica‐

tion first, 3 * 4 is 12 , and 2 + 12 is 14. In Python, as in most languages, multiplica‐

tion has higher precedence than addition, so the second version is what you’d see:

```
>>> 2 + 3 * 4
14
```
How do you know the precedence rules? There’s a big table in Appendix E that lists

them all, but I’ve found that in practice I never look up these rules. It’s much easier to

just add parentheses to group your code as you intend the calculation to be carried

out:

```
>>> 2 + (3 * 4)
14
```
This example with exponents

```
>>> -5 ** 2
-25
```
is the same as

```
>>> - (5 ** 2)
-25
```
and probably not what you wanted. Parentheses make it clear:

```
>>> (-5) ** 2
25
```
This way, anyone reading the code doesn’t need to guess its intent or look up prece‐

dence rules.

#### Bases

Integers are assumed to be decimal (base 10) unless you use a prefix to specify

another base. You might never need to use these other bases, but you’ll probably see

them in Python code somewhere, sometime.

We generally have 10 fingers and 10 toes, so we count 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9. Next,

we run out of single digits and carry the one to the “ten’s place” and put a 0 in the

one’s place: 10 means “1 ten and 0 ones.” Unlike Roman numerals, Arabic numbers

don’t have a single character that represents “10” Then, it’s 11 , 12 , up to 19 , carry the

one to make 20 (2 tens and 0 ones), and so on.

A base is how many digits you can use until you need to “carry the one.” In base 2

(binary), the only digits are 0 and 1. This is the famous bit. 0 is the same as a plain

old decimal 0, and 1 is the same as a decimal 1. However, in base 2, if you add a 1 to a

1 , you get 10 (1 decimal two plus 0 decimal ones).

**44 | Chapter 3: Numbers**


In Python, you can express literal integers in three bases besides decimal with these

integer prefixes:

- 0b or 0B for binary (base 2).
- 0o or 0O for octal (base 8).
- 0x or 0X for hex (base 16).

These bases are all powers of two, and are handy in some cases, although you may

never need to use anything other than good old decimal integers.

The interpreter prints these for you as decimal integers. Let’s try each of these bases.

First, a plain old decimal 10 , which means 1 ten and 0 ones:

```
>>> 10
10
```
Now, a binary (base two) 0b10, which means 1 (decimal) two and 0 ones:

```
>>> 0b10
2
```
Octal (base 8) 0o10 stands for 1 (decimal) eight and 0 ones:

```
>>> 0o10
8
```
Hexadecimal (base 16) 0x10 means 1 (decimal) sixteen and 0 ones:

```
>>> 0x10
16
```
You can go the other direction, converting an integer to a string with any of these

bases:

```
>>> value = 65
>>> bin(value)
'0b1000001'
>>> oct(value)
'0o101'
>>> hex(value)
'0x41'
```
The chr() function converts an integer to its single-character string equivalent:

```
>>> chr(65)
'A'
```
And ord() goes the other way:

```
>>> ord('A')
65
```
```
Integers | 45
```

In case you’re wondering what “digits” base 16 uses, they are: 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ,

a, b, c, d, e, and f. 0xa is a decimal 10 , and 0xf is a decimal 15. Add 1 to 0xf and you

get 0x10 (decimal 16).

Why use different bases from 10? They’re useful in bit-level operations, which are

described in Chapter 12, along with more details about converting numbers from one

base to another.

Cats normally have five digits on each forepaw and four on each hindpaw, for a total

of 18. If you ever encounter cat scientists in their lab coats, they’re often discussing

base-18 arithmetic. My cat Chester, seen lounging about in Figure 3-1, is a polydactyl,

giving him a total of 22 or so (they’re hard to distinguish) toes. If he wanted to use all

of them to count food fragments surrounding his bowl, he would likely use a base-22

system (hereafter, the chesterdigital system), using 0 through 9 and a through l.

Figure 3-1. Chester—a fine furry fellow, and inventor of the chesterdigital system

**46 | Chapter 3: Numbers**


#### Type Conversions

To change other Python data types to an integer, use the int() function.

The int() function takes one input argument and returns one value, the integer-ized

equivalent of the input argument. This will keep the whole number and discard any

fractional part.

As you saw at the start of this chapter, Python’s simplest data type is the boolean,

which has only the values True and False. When converted to integers, they repre‐

sent the values 1 and 0 :

```
>>> int(True)
1
>>> int(False)
0
```
Turning this around, the bool() function returns the boolean equivalent of an

integer:

```
>>> bool(1)
True
>>> bool(0)
False
```
Converting a floating-point number to an integer just lops off everything after the

decimal point:

```
>>> int(98.6)
98
>>> int(1.0e4)
10000
```
Converting a float to a boolean is no surprise:

```
>>> bool(1.0)
True
>>> bool(0.0)
False
```
Finally, here’s an example of getting the integer value from a text string (Chapter 5)

that contains only digits, possibly with _ digit separators or an initial + or - sign:

```
>>> int('99')
99
>>> int('-23')
-23
>>> int('+12')
12
>>> int('1_000_000')
1000000
```
```
Integers | 47
```

If the string represents a nondecimal integer, you can include the base:

```
>>> int('10', 2) # binary
2
>>> int('10', 8) # octal
8
>>> int('10', 16) # hexadecimal
16
>>> int('10', 22) # chesterdigital
22
```
Converting an integer to an integer doesn’t change anything, but doesn’t hurt either:

```
>>> int(12345)
12345
```
If you try to convert something that doesn’t look like a number, you’ll get an

exception:

```
>>> int('99 bottles of beer on the wall')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '99 bottles of beer on the wall'
>>> int('')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: ''
```
The preceding text string started with valid digit characters ( 99 ), but it kept on going

with others that the int() function just wouldn’t stand for.

int() will make integers from floats or strings of digits, but it won’t handle strings

containing decimal points or exponents:

```
>>> int('98.6')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '98.6'
>>> int('1.0e4')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '1.0e4'
```
If you mix numeric types, Python will sometimes try to automatically convert them

for you:

```
>>> 4 + 7.0
11.0
```
The boolean value False is treated as 0 or 0.0 when mixed with integers or floats,

and True is treated as 1 or 1.0:

```
>>> True + 2
3
```
**48 | Chapter 3: Numbers**


```
>>> False + 5.0
5.0
```
#### How Big Is an int?

In Python 2, the size of an int could be limited to 32 or 64 bits, depending on your

CPU; 32 bits can store store any integer from –2,147,483,648 to 2,147,483,647.

A long had 64 bits, allowing values from –9,223,372,036,854,775,808 to

9,223,372,036,854,775,807. In Python 3, the long type is long gone, and an int can be

any size—even greater than 64 bits. You can play with big numbers like a googol (one

followed by a hundred zeroes, named in 1920 by a nine-year-old boy):

```
>>>
>>> googol = 10**100
>>> googol
100000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000
>>> googol * googol
100000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000
```
A googolplex is 10**googol (a thousand zeroes, if you want to try it yourself ). This

was a suggested name for Google before they decided on googol, but didn’t check its

spelling before registering the domain name google.com.

In many languages, trying this would cause something called integer overflow, where

the number would need more space than the computer allowed for it, with various

bad effects. Python handles googoly integers with no problem.

### Floats

Integers are whole numbers, but floating-point numbers (called floats in Python) have

decimal points:

```
>>> 5.
5.0
>>> 5.0
5.0
>>> 05.0
5.0
```
Floats can include a decimal integer exponent after the letter e:

```
>>> 5e0
5.0
>>> 5e1
50.0
>>> 5.0e1
```
```
Floats | 49
```

##### 50.0

##### >>> 5.0 * (10 ** 1)

##### 50.0

You can use underscore (_) to separate digits for clarity, as you can for integers:

```
>>> million = 1_000_000.0
>>> million
1000000.0
>>> 1.0_0_1
1.001
```
Floats are handled similarly to integers: you can use the operators (+, –, *, /, //, **,

and %) and the divmod() function.

To convert other types to floats, you use the float() function. As before, booleans act

like tiny integers:

```
>>> float(True)
1.0
>>> float(False)
0.0
```
Converting an integer to a float just makes it the proud possessor of a decimal point:

```
>>> float(98)
98.0
>>> float('99')
99.0
```
And you can convert a string containing characters that would be a valid float (digits,

signs, decimal point, or an e followed by an exponent) to a real float:

```
>>> float('98.6')
98.6
>>> float('-1.5')
-1.5
>>> float('1.0e4')
10000.0
```
When you mix integers and floats, Python automatically promotes the integer values

to float values:

```
>>> 43 + 2.
45.0
```
Python also promotes booleans to integers or floats:

```
>>> False + 0
0
>>> False + 0.
0.0
>>> True + 0
1
```
**50 | Chapter 3: Numbers**


```
>>> True + 0.
1.0
```
### Math Functions

Python supports complex numbers and has the usual math functions such as square

roots, cosines, and so on. Let’s save them for Chapter 22, in which we also discuss

using Python in science contexts.

### Coming Up

In the next chapter, you finally graduate from one-line Python examples. With the if

statement, you’ll learn how to make decisions with code.

### Things to Do

This chapter introduced the atoms of Python: numbers, booleans, and variables. Let’s

try a few small exercises with them in the interactive interpreter.

3.1 How many seconds are in an hour? Use the interactive interpreter as a calculator

and multiply the number of seconds in a minute ( 60 ) by the number of minutes in an

hour (also 60 ).

3.2 Assign the result from the previous task (seconds in an hour) to a variable called

seconds_per_hour.

3.3 How many seconds are in a day? Use your seconds_per_hour variable.

3.4 Calculate seconds per day again, but this time save the result in a variable called

seconds_per_day.

3.5 Divide seconds_per_day by seconds_per_hour. Use floating-point (/) division.

3.6 Divide seconds_per_day by seconds_per_hour, using integer (//) division. Did

this number agree with the floating-point value from the previous question, aside

from the final .0?
